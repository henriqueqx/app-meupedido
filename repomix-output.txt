This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-04T00:47:07.575Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.cursorrules
.gitignore
app-example/_layout.tsx
app-example/(tabs)/_layout.tsx
app-example/(tabs)/explore.tsx
app-example/(tabs)/index.tsx
app-example/+html.tsx
app-example/+not-found.tsx
app.json
app/_layout.tsx
app/components/CustomerAutocomplete.tsx
app/components/TemporaryScreen.tsx
app/contexts/AuthContext.tsx
app/index.tsx
app/InitialLayout.tsx
app/screens/cashier.tsx
app/screens/customers.tsx
app/screens/customers/details.tsx
app/screens/customers/edit.tsx
app/screens/customers/new.tsx
app/screens/home.tsx
app/screens/orders.tsx
app/screens/products.tsx
app/screens/products/edit.tsx
app/screens/products/new.tsx
app/screens/profile.tsx
app/screens/reports.tsx
app/screens/sales/new.tsx
app/screens/settings.tsx
app/screens/users.tsx
app/screens/users/edit.tsx
app/screens/users/new.tsx
babel.config.js
components/__tests__/__snapshots__/ThemedText-test.tsx.snap
components/__tests__/ThemedText-test.tsx
components/Collapsible.tsx
components/ExternalLink.tsx
components/HelloWave.tsx
components/navigation/TabBarIcon.tsx
components/ParallaxScrollView.tsx
components/ThemedText.tsx
components/ThemedView.tsx
constants/Colors.ts
contexts/AuthContext.tsx
database/cashRepository.ts
database/customerRepository.ts
database/database.ts
database/orderRepository.ts
database/productRepository.ts
database/userRepository.ts
eas.json
hooks/useColorScheme.ts
hooks/useColorScheme.web.ts
hooks/useThemeColor.ts
package.json
README.md
scripts/reset-project.js
tsconfig.json
utils/format.ts

================================================================
Repository Files
================================================================

================
File: .cursorrules
================
// React Native Expo .cursorrules

// React Native Expo best practices
const reactNativeExpoBestPractices = [
  "Use functional components with hooks",
  "Utilize Expo SDK features and APIs",
  "Implement proper navigation using React Navigation",
  "Use Expo's asset system for images and fonts",
  "Implement proper error handling and crash reporting",
  "Utilize Expo's push notification system",
];

// Folder structure
const folderStructure = `
assets/
src/
  components/
  screens/
  navigation/
  hooks/
  utils/
App.js
app.json
`;

// Additional instructions
const additionalInstructions = `
1. Use TypeScript for type safety
2. Implement proper styling using StyleSheet
3. Utilize Expo's vector icons
4. Use Expo's secure store for sensitive data
5. Implement proper offline support
6. Follow React Native best practices for performance
7. Use Expo's OTA updates for quick deployments
`;

================
File: .gitignore
================
node_modules/
.expo/
dist/
npm-debug.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision
*.orig.*
web-build/

# macOS
.DS_Store

# @generated expo-cli sync-2b81b286409207a5da26e14c78851eb30d8ccbdb
# The following patterns were generated by expo-cli

expo-env.d.ts
# @end expo-cli
%ProgramData%/
%ProgramData%/Microsoft/Windows/UUS/State/_active.uusver
credentials.json
my-upload-key.keystore
android/

================
File: app-example/_layout.tsx
================
import { DarkTheme, DefaultTheme, ThemeProvider } from '@react-navigation/native';
import { useFonts } from 'expo-font';
import { Stack } from 'expo-router';
import * as SplashScreen from 'expo-splash-screen';
import { useEffect } from 'react';
import 'react-native-reanimated';

import { useColorScheme } from '@/hooks/useColorScheme';

// Prevent the splash screen from auto-hiding before asset loading is complete.
SplashScreen.preventAutoHideAsync();

export default function RootLayout() {
  const colorScheme = useColorScheme();
  const [loaded] = useFonts({
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
  });

  useEffect(() => {
    if (loaded) {
      SplashScreen.hideAsync();
    }
  }, [loaded]);

  if (!loaded) {
    return null;
  }

  return (
    <ThemeProvider value={colorScheme === 'dark' ? DarkTheme : DefaultTheme}>
      <Stack>
        <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
        <Stack.Screen name="+not-found" />
      </Stack>
    </ThemeProvider>
  );
}

================
File: app-example/(tabs)/_layout.tsx
================
import { Tabs } from 'expo-router';
import React from 'react';

import { TabBarIcon } from '@/components/navigation/TabBarIcon';
import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function TabLayout() {
  const colorScheme = useColorScheme();

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: Colors[colorScheme ?? 'light'].tint,
        headerShown: false,
      }}>
      <Tabs.Screen
        name="index"
        options={{
          title: 'Home',
          tabBarIcon: ({ color, focused }) => (
            <TabBarIcon name={focused ? 'home' : 'home-outline'} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="explore"
        options={{
          title: 'Explore',
          tabBarIcon: ({ color, focused }) => (
            <TabBarIcon name={focused ? 'code-slash' : 'code-slash-outline'} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}

================
File: app-example/(tabs)/explore.tsx
================
import Ionicons from '@expo/vector-icons/Ionicons';
import { StyleSheet, Image, Platform } from 'react-native';

import { Collapsible } from '@/components/Collapsible';
import { ExternalLink } from '@/components/ExternalLink';
import ParallaxScrollView from '@/components/ParallaxScrollView';
import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';

export default function TabTwoScreen() {
  return (
    <ParallaxScrollView
      headerBackgroundColor={{ light: '#D0D0D0', dark: '#353636' }}
      headerImage={<Ionicons size={310} name="code-slash" style={styles.headerImage} />}>
      <ThemedView style={styles.titleContainer}>
        <ThemedText type="title">Explore</ThemedText>
      </ThemedView>
      <ThemedText>This app includes example code to help you get started.</ThemedText>
      <Collapsible title="File-based routing">
        <ThemedText>
          This app has two screens:{' '}
          <ThemedText type="defaultSemiBold">app/(tabs)/index.tsx</ThemedText> and{' '}
          <ThemedText type="defaultSemiBold">app/(tabs)/explore.tsx</ThemedText>
        </ThemedText>
        <ThemedText>
          The layout file in <ThemedText type="defaultSemiBold">app/(tabs)/_layout.tsx</ThemedText>{' '}
          sets up the tab navigator.
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/router/introduction">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Android, iOS, and web support">
        <ThemedText>
          You can open this project on Android, iOS, and the web. To open the web version, press{' '}
          <ThemedText type="defaultSemiBold">w</ThemedText> in the terminal running this project.
        </ThemedText>
      </Collapsible>
      <Collapsible title="Images">
        <ThemedText>
          For static images, you can use the <ThemedText type="defaultSemiBold">@2x</ThemedText> and{' '}
          <ThemedText type="defaultSemiBold">@3x</ThemedText> suffixes to provide files for
          different screen densities
        </ThemedText>
        <Image source={require('@/assets/images/react-logo.png')} style={{ alignSelf: 'center' }} />
        <ExternalLink href="https://reactnative.dev/docs/images">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Custom fonts">
        <ThemedText>
          Open <ThemedText type="defaultSemiBold">app/_layout.tsx</ThemedText> to see how to load{' '}
          <ThemedText style={{ fontFamily: 'SpaceMono' }}>
            custom fonts such as this one.
          </ThemedText>
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/versions/latest/sdk/font">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Light and dark mode components">
        <ThemedText>
          This template has light and dark mode support. The{' '}
          <ThemedText type="defaultSemiBold">useColorScheme()</ThemedText> hook lets you inspect
          what the user's current color scheme is, and so you can adjust UI colors accordingly.
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/develop/user-interface/color-themes/">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Animations">
        <ThemedText>
          This template includes an example of an animated component. The{' '}
          <ThemedText type="defaultSemiBold">components/HelloWave.tsx</ThemedText> component uses
          the powerful <ThemedText type="defaultSemiBold">react-native-reanimated</ThemedText> library
          to create a waving hand animation.
        </ThemedText>
        {Platform.select({
          ios: (
            <ThemedText>
              The <ThemedText type="defaultSemiBold">components/ParallaxScrollView.tsx</ThemedText>{' '}
              component provides a parallax effect for the header image.
            </ThemedText>
          ),
        })}
      </Collapsible>
    </ParallaxScrollView>
  );
}

const styles = StyleSheet.create({
  headerImage: {
    color: '#808080',
    bottom: -90,
    left: -35,
    position: 'absolute',
  },
  titleContainer: {
    flexDirection: 'row',
    gap: 8,
  },
});

================
File: app-example/(tabs)/index.tsx
================
import { Image, StyleSheet, Platform } from 'react-native';

import { HelloWave } from '@/components/HelloWave';
import ParallaxScrollView from '@/components/ParallaxScrollView';
import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';

export default function HomeScreen() {
  return (
    <ParallaxScrollView
      headerBackgroundColor={{ light: '#A1CEDC', dark: '#1D3D47' }}
      headerImage={
        <Image
          source={require('@/assets/images/partial-react-logo.png')}
          style={styles.reactLogo}
        />
      }>
      <ThemedView style={styles.titleContainer}>
        <ThemedText type="title">Welcome!</ThemedText>
        <HelloWave />
      </ThemedView>
      <ThemedView style={styles.stepContainer}>
        <ThemedText type="subtitle">Step 1: Try it</ThemedText>
        <ThemedText>
          Edit <ThemedText type="defaultSemiBold">app/(tabs)/index.tsx</ThemedText> to see changes.
          Press{' '}
          <ThemedText type="defaultSemiBold">
            {Platform.select({ ios: 'cmd + d', android: 'cmd + m' })}
          </ThemedText>{' '}
          to open developer tools.
        </ThemedText>
      </ThemedView>
      <ThemedView style={styles.stepContainer}>
        <ThemedText type="subtitle">Step 2: Explore</ThemedText>
        <ThemedText>
          Tap the Explore tab to learn more about what's included in this starter app.
        </ThemedText>
      </ThemedView>
      <ThemedView style={styles.stepContainer}>
        <ThemedText type="subtitle">Step 3: Get a fresh start</ThemedText>
        <ThemedText>
          When you're ready, run{' '}
          <ThemedText type="defaultSemiBold">npm run reset-project</ThemedText> to get a fresh{' '}
          <ThemedText type="defaultSemiBold">app</ThemedText> directory. This will move the current{' '}
          <ThemedText type="defaultSemiBold">app</ThemedText> to{' '}
          <ThemedText type="defaultSemiBold">app-example</ThemedText>.
        </ThemedText>
      </ThemedView>
    </ParallaxScrollView>
  );
}

const styles = StyleSheet.create({
  titleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  stepContainer: {
    gap: 8,
    marginBottom: 8,
  },
  reactLogo: {
    height: 178,
    width: 290,
    bottom: 0,
    left: 0,
    position: 'absolute',
  },
});

================
File: app-example/+html.tsx
================
import { ScrollViewStyleReset } from 'expo-router/html';
import { type PropsWithChildren } from 'react';

/**
 * This file is web-only and used to configure the root HTML for every web page during static rendering.
 * The contents of this function only run in Node.js environments and do not have access to the DOM or browser APIs.
 */
export default function Root({ children }: PropsWithChildren) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta httpEquiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

        {/*
          Disable body scrolling on web. This makes ScrollView components work closer to how they do on native.
          However, body scrolling is often nice to have for mobile web. If you want to enable it, remove this line.
        */}
        <ScrollViewStyleReset />

        {/* Using raw CSS styles as an escape-hatch to ensure the background color never flickers in dark-mode. */}
        <style dangerouslySetInnerHTML={{ __html: responsiveBackground }} />
        {/* Add any additional <head> elements that you want globally available on web... */}
      </head>
      <body>{children}</body>
    </html>
  );
}

const responsiveBackground = `
body {
  background-color: #fff;
}
@media (prefers-color-scheme: dark) {
  body {
    background-color: #000;
  }
}`;

================
File: app-example/+not-found.tsx
================
import { Link, Stack } from 'expo-router';
import { StyleSheet } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <ThemedView style={styles.container}>
        <ThemedText type="title">This screen doesn't exist.</ThemedText>
        <Link href="/" style={styles.link}>
          <ThemedText type="link">Go to home screen!</ThemedText>
        </Link>
      </ThemedView>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});

================
File: app.json
================
{
  "expo": {
    "name": "app-meupedido",
    "slug": "app-meupedido",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "splash": {
      "image": "./assets/images/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.henriqueqx.appmeupedido"
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router"
    ],
    "experiments": {
      "typedRoutes": true
    },
    "extra": {
      "eas": {
        "projectId": "e6eab5c7-c2cb-45e6-a3bb-1be653e190b5"
      }
    }
  }
}

================
File: app/_layout.tsx
================
import { Stack } from "expo-router";
import { useEffect, useState } from "react";
import { initDatabase } from "../database/database";
import { AuthProvider } from "./contexts/AuthContext";
import { InitialLayout } from "./InitialLayout";
import { View, ActivityIndicator } from "react-native";

export default function RootLayout() {
  const [isDbReady, setIsDbReady] = useState(false);

  useEffect(() => {
    const init = async () => {
      try {
        await initDatabase();
        console.log('Banco de dados inicializado');
        setIsDbReady(true);
      } catch (error) {
        console.error('Erro ao inicializar banco:', error);
      }
    };

    init();
  }, []);

  if (!isDbReady) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" color="#0a7ea4" />
      </View>
    );
  }

  return (
    <AuthProvider>
      <InitialLayout />
    </AuthProvider>
  );
}

================
File: app/components/CustomerAutocomplete.tsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  FlatList,
  StyleSheet,
  ActivityIndicator,
} from 'react-native';
import { customerRepository, Customer } from '../../database/customerRepository';

interface CustomerAutocompleteProps {
  onSelect: (customer: Customer) => void;
  value: string;
  onChangeText: (text: string) => void;
}

export function CustomerAutocomplete({ onSelect, value, onChangeText }: CustomerAutocompleteProps) {
  const [suggestions, setSuggestions] = useState<Customer[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [showSuggestions, setShowSuggestions] = useState(false);

  const searchCustomers = async (searchText: string) => {
    if (!searchText) {
      setSuggestions([]);
      return;
    }

    try {
      setIsLoading(true);
      const customers = await customerRepository.findByName(searchText);
      setSuggestions(customers);
      setShowSuggestions(true);
    } catch (error) {
      console.error('Erro ao buscar clientes:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleSelectCustomer = (customer: Customer) => {
    onSelect(customer);
    onChangeText(customer.name);
    setShowSuggestions(false);
  };

  useEffect(() => {
    const delaySearch = setTimeout(() => {
      searchCustomers(value);
    }, 300);

    return () => clearTimeout(delaySearch);
  }, [value]);

  return (
    <View style={styles.container}>
      <View style={styles.inputContainer}>
        <TextInput
          style={styles.input}
          value={value}
          onChangeText={(text) => {
            onChangeText(text);
            setShowSuggestions(true);
          }}
          placeholder="Nome do cliente"
          onFocus={() => value && searchCustomers(value)}
        />
        {isLoading && (
          <ActivityIndicator style={styles.loadingIndicator} size="small" color="#0a7ea4" />
        )}
      </View>

      {showSuggestions && suggestions.length > 0 && (
        <View style={styles.suggestionsContainer}>
          <FlatList
            data={suggestions}
            keyExtractor={(item) => item.id!.toString()}
            keyboardShouldPersistTaps="handled"
            renderItem={({ item }) => (
              <TouchableOpacity
                style={styles.suggestionItem}
                onPress={() => handleSelectCustomer(item)}
              >
                <Text style={styles.suggestionName}>{item.name}</Text>
                {item.phone && (
                  <Text style={styles.suggestionDetail}>📱 {item.phone}</Text>
                )}
              </TouchableOpacity>
            )}
          />
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    position: 'relative',
    zIndex: 1,
    flex: 1,
    marginRight: 8,
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  input: {
    flex: 1,
    backgroundColor: '#FFF',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    borderWidth: 1,
    borderColor: '#DDD',
    height: 45,
  },
  loadingIndicator: {
    position: 'absolute',
    right: 12,
  },
  suggestionsContainer: {
    position: 'absolute',
    top: '100%',
    left: 0,
    right: 0,
    backgroundColor: '#FFF',
    borderRadius: 8,
    maxHeight: 200,
    marginTop: 4,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  suggestionItem: {
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#EEE',
  },
  suggestionName: {
    fontSize: 16,
    color: '#333',
  },
  suggestionDetail: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
});

================
File: app/components/TemporaryScreen.tsx
================
import { View, Text, StyleSheet } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

interface TemporaryScreenProps {
  title: string;
  icon: keyof typeof Ionicons.glyphMap;
  color?: string;
}

export function TemporaryScreen({ title, icon, color = "#0a7ea4" }: TemporaryScreenProps) {
  return (
    <View style={styles.container}>
      <Ionicons name={icon} size={64} color={color} />
      <Text style={[styles.title, { color }]}>{title}</Text>
      <Text style={styles.subtitle}>Em desenvolvimento...</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#fff',
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 16,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    marginTop: 8,
  },
});

================
File: app/contexts/AuthContext.tsx
================
import { createContext, useContext, useState, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { User } from '../../database/userRepository';

interface AuthContextData {
  user: User | null;
  signIn: (user: User) => Promise<void>;
  signOut: () => Promise<void>;
  isLoading: boolean;
}

const AuthContext = createContext<AuthContextData>({} as AuthContextData);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    loadStoredData();
  }, []);

  async function loadStoredData() {
    try {
      const storedUser = await AsyncStorage.getItem('@LanchoneteApp:user');
      if (storedUser) {
        setUser(JSON.parse(storedUser));
      }
    } catch (error) {
      console.error('Erro ao carregar dados do usuário:', error);
    } finally {
      setIsLoading(false);
    }
  }

  async function signIn(userData: User) {
    try {
      await AsyncStorage.setItem('@LanchoneteApp:user', JSON.stringify(userData));
      setUser(userData);
    } catch (error) {
      console.error('Erro ao salvar dados do usuário:', error);
      throw error;
    }
  }

  async function signOut() {
    try {
      await AsyncStorage.removeItem('@LanchoneteApp:user');
      setUser(null);
    } catch (error) {
      console.error('Erro ao remover dados do usuário:', error);
      throw error;
    }
  }

  return (
    <AuthContext.Provider value={{ user, signIn, signOut, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

================
File: app/index.tsx
================
import { useState } from "react";
import { 
  Text, 
  View, 
  TextInput, 
  TouchableOpacity, 
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  Alert,
  ActivityIndicator
} from "react-native";
import { Ionicons } from '@expo/vector-icons';
import { userRepository } from '../database/userRepository';
import { useRouter } from 'expo-router';
import { useAuth } from './contexts/AuthContext';

export default function Login() {
  const router = useRouter();
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const { signIn } = useAuth();

  const handleLogin = async () => {
    if (!username || !password) {
      Alert.alert('Erro', 'Por favor, preencha todos os campos');
      return;
    }

    try {
      setIsLoading(true);
      const user = await userRepository.authenticate(username, password);
      
      if (user) {
        await signIn(user);
        router.replace('screens/home' as any);
      } else {
        Alert.alert(
          'Erro', 
          'Usuário ou senha inválidos',
          [
            { 
              text: 'OK',
              onPress: () => {
                setPassword('');
              }
            }
          ]
        );
      }
    } catch (error) {
      console.error('Erro ao realizar login:', error);
      Alert.alert('Erro', 'Ocorreu um erro ao tentar fazer login. Tente novamente.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <KeyboardAvoidingView
      behavior={Platform.OS === "ios" ? "padding" : "height"}
      style={styles.container}
    >
      <View style={styles.logoContainer}>
        <Ionicons name="restaurant" size={100} color="#0a7ea4" />
        <Text style={styles.logoText}>Lanchonete App</Text>
      </View>

      <View style={styles.formContainer}>
        <View style={styles.inputContainer}>
          <Ionicons name="person-outline" size={20} color="#999" style={styles.inputIcon} />
          <TextInput
            style={styles.input}
            placeholder="Usuário"
            placeholderTextColor="#999"
            value={username}
            onChangeText={setUsername}
            autoCapitalize="none"
            autoCorrect={false}
            editable={!isLoading}
          />
        </View>

        <View style={styles.inputContainer}>
          <Ionicons name="lock-closed-outline" size={20} color="#999" style={styles.inputIcon} />
          <TextInput
            style={styles.input}
            placeholder="Senha"
            placeholderTextColor="#999"
            value={password}
            onChangeText={setPassword}
            secureTextEntry
            editable={!isLoading}
          />
        </View>

        <TouchableOpacity 
          style={[styles.loginButton, isLoading && styles.loginButtonDisabled]}
          onPress={handleLogin}
          disabled={isLoading}
        >
          {isLoading ? (
            <ActivityIndicator color="#FFF" />
          ) : (
            <Text style={styles.loginButtonText}>Entrar</Text>
          )}
        </TouchableOpacity>

        <TouchableOpacity 
          style={styles.forgotPassword}
          disabled={isLoading}
        >
          <Text style={styles.forgotPasswordText}>Esqueceu sua senha?</Text>
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#fff",
  },
  logoContainer: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  logoText: {
    fontSize: 24,
    fontWeight: "bold",
    color: "#0a7ea4",
    marginTop: 10
  },
  formContainer: {
    flex: 2,
    paddingHorizontal: 30,
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    height: 50,
    backgroundColor: "#F5F5F5",
    borderRadius: 8,
    marginBottom: 16,
    paddingHorizontal: 16,
  },
  inputIcon: {
    marginRight: 10,
  },
  input: {
    flex: 1,
    fontSize: 16,
    color: "#333",
  },
  loginButton: {
    height: 50,
    backgroundColor: "#0a7ea4",
    borderRadius: 8,
    alignItems: "center",
    justifyContent: "center",
    marginTop: 16,
  },
  loginButtonText: {
    color: "#FFF",
    fontSize: 16,
    fontWeight: "bold",
  },
  forgotPassword: {
    alignItems: "center",
    marginTop: 16,
  },
  forgotPasswordText: {
    color: "#0a7ea4",
    fontSize: 14,
  },
  loginButtonDisabled: {
    backgroundColor: "#999",
  },
});

================
File: app/InitialLayout.tsx
================
import { Stack, useRouter } from "expo-router";
import { useEffect } from "react";
import { useAuth } from './contexts/AuthContext';
import { ActivityIndicator, View } from "react-native";

export function InitialLayout() {
  const { user, isLoading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!isLoading) {
      if (user) {
        router.replace('/screens/home');
      } else {
        router.replace('/');
      }
    }
  }, [isLoading]);

  if (isLoading) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#fff' }}>
        <ActivityIndicator size="large" color="#0a7ea4" />
      </View>
    );
  }

  return (
    <Stack>
      <Stack.Screen 
        name="index" 
        options={{ 
          headerShown: false 
        }} 
      />
      <Stack.Screen 
        name="screens/home" 
        options={{ 
          headerShown: false,
          gestureEnabled: false 
        }} 
      />
      <Stack.Screen 
        name="screens/profile" 
        options={{ 
          title: 'Meu Perfil' 
        }} 
      />
      <Stack.Screen 
        name="screens/products" 
        options={{ 
          title: 'Produtos' 
        }} 
      />
      <Stack.Screen 
        name="screens/products/new" 
        options={{ 
          title: 'Novo Produto',
          presentation: 'modal'
        }} 
      />
      <Stack.Screen 
        name="screens/products/edit" 
        options={{ 
          title: 'Editar Produto'
        }} 
      />
      <Stack.Screen 
        name="screens/customers" 
        options={{ 
          title: 'Clientes' 
        }} 
      />
      <Stack.Screen 
        name="screens/orders" 
        options={{ 
          title: 'Pedidos' 
        }} 
      />
      <Stack.Screen 
        name="screens/reports" 
        options={{ 
          title: 'Relatórios' 
        }} 
      />
      <Stack.Screen 
        name="screens/settings" 
        options={{ 
          title: 'Configurações' 
        }} 
      />
      <Stack.Screen 
        name="screens/users" 
        options={{ 
          title: 'Usuários' 
        }} 
      />
      <Stack.Screen 
        name="screens/cashier" 
        options={{ 
          title: 'Caixa' 
        }} 
      />
      <Stack.Screen 
        name="screens/sales/new" 
        options={{ 
          title: 'Nova Venda' 
        }} 
      />
      <Stack.Screen 
        name="screens/users/new" 
        options={{ 
          title: 'Novo Usuário',
          presentation: 'modal'
        }} 
      />
      <Stack.Screen 
        name="screens/users/edit" 
        options={{ 
          title: 'Editar Usuário'
        }} 
      />
      <Stack.Screen 
        name="screens/customers/new" 
        options={{ 
          title: 'Novo Cliente',
          presentation: 'modal'
        }} 
      />
      <Stack.Screen 
        name="screens/customers/edit" 
        options={{ 
          title: 'Editar Cliente'
        }} 
      />
    </Stack>
  );
}

================
File: app/screens/cashier.tsx
================
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Alert,
  ScrollView,
  ActivityIndicator,
  RefreshControl,
  Modal,
  TextInput,
} from 'react-native';
import { useRouter } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import { cashRepository, CashStatus, CashMovement } from '../../database/cashRepository';
import { useAuth } from '../contexts/AuthContext';
import { formatCurrency } from '../../utils/format';

export default function Cashier() {
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [cashStatus, setCashStatus] = useState<CashStatus | null>(null);
  const [movements, setMovements] = useState<CashMovement[]>([]);
  const [showOpenCashModal, setShowOpenCashModal] = useState(false);
  const [initialAmount, setInitialAmount] = useState('');
  const { user } = useAuth();
  const router = useRouter();

  const loadData = useCallback(async () => {
    try {
      const status = await cashRepository.getCurrentStatus();
      setCashStatus(status);
      
      if (status?.is_open) {
        const todayMovements = await cashRepository.getMovements(
          new Date().toISOString().split('T')[0]
        );
        setMovements(todayMovements);
      }
    } catch (error) {
      console.error('Erro ao carregar dados do caixa:', error);
      Alert.alert('Erro', 'Não foi possível carregar os dados do caixa');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    loadData();
  }, [loadData]);

  const handleOpenCashier = async () => {
    if (!initialAmount) {
      Alert.alert('Erro', 'Digite o valor inicial do caixa');
      return;
    }

    const amount = parseFloat(initialAmount.replace(',', '.'));
    if (isNaN(amount) || amount <= 0) {
      Alert.alert('Erro', 'Digite um valor válido');
      return;
    }

    try {
      await cashRepository.openCashier(user!.id!, amount);
      setShowOpenCashModal(false);
      setInitialAmount('');
      loadData();
    } catch (error) {
      console.error('Erro ao abrir caixa:', error);
      Alert.alert('Erro', 'Não foi possível abrir o caixa');
    }
  };

  const handleCloseCashier = async () => {
    Alert.alert(
      'Fechar Caixa',
      'Deseja realmente fechar o caixa?',
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Fechar',
          style: 'destructive',
          onPress: async () => {
            try {
              await cashRepository.closeCashier(user!.id!);
              loadData();
            } catch (error) {
              console.error('Erro ao fechar caixa:', error);
              Alert.alert('Erro', 'Não foi possível fechar o caixa');
            }
          }
        }
      ]
    );
  };

  const handleAddMovement = async (type: CashMovement['type']) => {
    try {
      const amount = await new Promise<number>((resolve) => {
        Alert.prompt(
          type === 'deposit' ? 'Adicionar Entrada' : 'Adicionar Saída',
          'Digite o valor:',
          [
            { text: 'Cancelar', style: 'cancel' },
            {
              text: 'Confirmar',
              onPress: (value) => {
                const amount = parseFloat(value?.replace(',', '.') || '0');
                resolve(amount);
              }
            }
          ],
          'plain-text',
          '',
          'decimal-pad'
        );
      });

      if (amount > 0) {
        const description = await new Promise<string>((resolve) => {
          Alert.prompt(
            'Descrição',
            'Digite uma descrição para o movimento:',
            [
              { text: 'Cancelar', style: 'cancel' },
              {
                text: 'Confirmar',
                onPress: (value) => resolve(value || '')
              }
            ]
          );
        });

        await cashRepository.addMovement({
          type,
          amount,
          description,
          user_id: user!.id!
        });

        loadData();
      }
    } catch (error) {
      console.error('Erro ao adicionar movimento:', error);
      Alert.alert('Erro', 'Não foi possível adicionar o movimento');
    }
  };

  const onRefresh = useCallback(async () => {
    setIsRefreshing(true);
    await loadData();
    setIsRefreshing(false);
  }, [loadData]);

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0a7ea4" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Modal
        visible={showOpenCashModal}
        transparent
        animationType="slide"
        onRequestClose={() => setShowOpenCashModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Abrir Caixa</Text>
            
            <Text style={styles.modalLabel}>Valor inicial:</Text>
            <TextInput
              style={styles.modalInput}
              value={initialAmount}
              onChangeText={setInitialAmount}
              keyboardType="decimal-pad"
              placeholder="0,00"
            />

            <View style={styles.modalButtons}>
              <TouchableOpacity
                style={[styles.modalButton, styles.modalButtonCancel]}
                onPress={() => {
                  setShowOpenCashModal(false);
                  setInitialAmount('');
                }}
              >
                <Text style={styles.modalButtonText}>Cancelar</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.modalButton, styles.modalButtonConfirm]}
                onPress={handleOpenCashier}
              >
                <Text style={styles.modalButtonText}>Abrir</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      <View style={styles.header}>
        <View style={styles.statusContainer}>
          <Text style={styles.statusLabel}>Status:</Text>
          <Text style={[
            styles.statusValue,
            { color: cashStatus?.is_open ? '#27ae60' : '#e74c3c' }
          ]}>
            {cashStatus?.is_open ? 'Aberto' : 'Fechado'}
          </Text>
        </View>

        {cashStatus?.is_open ? (
          <>
            <View style={styles.amountContainer}>
              <Text style={styles.amountLabel}>Saldo Atual:</Text>
              <Text style={styles.amountValue}>
                {formatCurrency(cashStatus.current_amount)}
              </Text>
            </View>

            <View style={styles.actionsContainer}>
              <TouchableOpacity
                style={[styles.actionButton, { backgroundColor: '#27ae60' }]}
                onPress={() => handleAddMovement('deposit')}
              >
                <Ionicons name="add-circle-outline" size={24} color="#FFF" />
                <Text style={styles.actionButtonText}>Entrada</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.actionButton, { backgroundColor: '#e74c3c' }]}
                onPress={() => handleAddMovement('withdrawal')}
              >
                <Ionicons name="remove-circle-outline" size={24} color="#FFF" />
                <Text style={styles.actionButtonText}>Saída</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.actionButton, { backgroundColor: '#f39c12' }]}
                onPress={handleCloseCashier}
              >
                <Ionicons name="lock-closed-outline" size={24} color="#FFF" />
                <Text style={styles.actionButtonText}>Fechar</Text>
              </TouchableOpacity>
            </View>
          </>
        ) : (
          <TouchableOpacity
            style={[styles.actionButton, { backgroundColor: '#27ae60' }]}
            onPress={() => setShowOpenCashModal(true)}
          >
            <Ionicons name="lock-open-outline" size={24} color="#FFF" />
            <Text style={styles.actionButtonText}>Abrir Caixa</Text>
          </TouchableOpacity>
        )}
      </View>

      {cashStatus?.is_open && (
        <ScrollView
          style={styles.movementsList}
          refreshControl={
            <RefreshControl refreshing={isRefreshing} onRefresh={onRefresh} />
          }
        >
          <Text style={styles.movementsTitle}>Movimentações do Dia</Text>
          {movements.map((movement) => (
            <View key={movement.id} style={styles.movementItem}>
              <View style={styles.movementInfo}>
                <Text style={styles.movementType}>
                  {movement.type === 'sale' ? '🛍️ Venda' :
                   movement.type === 'deposit' ? '⬆️ Entrada' :
                   movement.type === 'withdrawal' ? '⬇️ Saída' :
                   movement.type === 'opening' ? '🔓 Abertura' :
                   movement.type === 'closing' ? '🔒 Fechamento' : '💰 Movimento'}
                </Text>
                <Text style={styles.movementDescription}>
                  {movement.description || 
                   (movement.order_id ? `Pedido - Mesa ${movement.table_number}` : '')}
                </Text>
              </View>
              <Text style={[
                styles.movementAmount,
                { 
                  color: ['withdrawal', 'expense'].includes(movement.type) 
                    ? '#e74c3c' 
                    : '#27ae60' 
                }
              ]}>
                {formatCurrency(movement.amount)}
              </Text>
            </View>
          ))}
        </ScrollView>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f6fa',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  header: {
    backgroundColor: '#FFF',
    padding: 16,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  statusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  statusLabel: {
    fontSize: 16,
    color: '#666',
    marginRight: 8,
  },
  statusValue: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  amountContainer: {
    marginBottom: 16,
  },
  amountLabel: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  amountValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#0a7ea4',
  },
  actionsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 12,
    borderRadius: 8,
    flex: 1,
    marginHorizontal: 4,
  },
  actionButtonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: 'bold',
    marginLeft: 4,
  },
  movementsList: {
    flex: 1,
    padding: 16,
  },
  movementsTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 16,
  },
  movementItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#FFF',
    padding: 16,
    borderRadius: 8,
    marginBottom: 8,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  movementInfo: {
    flex: 1,
  },
  movementType: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 4,
  },
  movementDescription: {
    fontSize: 14,
    color: '#666',
  },
  movementAmount: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    backgroundColor: '#FFF',
    borderRadius: 8,
    padding: 20,
    width: '80%',
    maxWidth: 400,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 20,
    textAlign: 'center',
  },
  modalLabel: {
    fontSize: 16,
    color: '#666',
    marginBottom: 8,
  },
  modalInput: {
    backgroundColor: '#f5f6fa',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    borderWidth: 1,
    borderColor: '#DDD',
    marginBottom: 20,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  modalButton: {
    flex: 1,
    padding: 12,
    borderRadius: 8,
    marginHorizontal: 5,
    alignItems: 'center',
  },
  modalButtonCancel: {
    backgroundColor: '#95a5a6',
  },
  modalButtonConfirm: {
    backgroundColor: '#27ae60',
  },
  modalButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
});

================
File: app/screens/customers.tsx
================
import { useState, useCallback } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  FlatList, 
  TouchableOpacity, 
  ActivityIndicator,
  Alert 
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { customerRepository, Customer } from '../../database/customerRepository';
import { useRouter } from 'expo-router';
import { useFocusEffect } from 'expo-router';

export default function Customers() {
  const [customers, setCustomers] = useState<Customer[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const router = useRouter();

  const loadCustomers = useCallback(async () => {
    try {
      setIsLoading(true);
      const customersList = await customerRepository.findAll();
      setCustomers(customersList);
    } catch (error) {
      console.error('Erro ao carregar clientes:', error);
      Alert.alert('Erro', 'Não foi possível carregar a lista de clientes');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useFocusEffect(
    useCallback(() => {
      loadCustomers();
    }, [loadCustomers])
  );

  const handleDeleteCustomer = async (id: number) => {
    Alert.alert(
      'Confirmar exclusão',
      'Deseja realmente excluir este cliente?',
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Excluir',
          style: 'destructive',
          onPress: async () => {
            try {
              await customerRepository.delete(id);
              loadCustomers();
            } catch (error) {
              console.error('Erro ao excluir cliente:', error);
              Alert.alert('Erro', 'Não foi possível excluir o cliente');
            }
          }
        }
      ]
    );
  };

  const renderCustomerItem = ({ item }: { item: Customer }) => (
    <View style={styles.customerCard}>
      <View style={styles.customerInfo}>
        <Text style={styles.customerName}>{item.name}</Text>
        {item.phone && (
          <Text style={styles.customerDetail}>📱 {item.phone}</Text>
        )}
        {item.email && (
          <Text style={styles.customerDetail}>📧 {item.email}</Text>
        )}
      </View>
      <View style={styles.customerActions}>
        <TouchableOpacity 
          onPress={() => router.push({
            pathname: 'screens/customers/edit',
            params: { customerId: item.id }
          } as any)}
          style={styles.actionButton}
        >
          <Ionicons name="create-outline" size={24} color="#0a7ea4" />
        </TouchableOpacity>
        <TouchableOpacity 
          onPress={() => handleDeleteCustomer(item.id!)}
          style={styles.actionButton}
        >
          <Ionicons name="trash-outline" size={24} color="#e74c3c" />
        </TouchableOpacity>
      </View>
    </View>
  );

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0a7ea4" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <TouchableOpacity 
        style={styles.addButton}
        onPress={() => router.push('screens/customers/new' as any)}
      >
        <Ionicons name="add" size={24} color="#FFF" />
        <Text style={styles.addButtonText}>Novo Cliente</Text>
      </TouchableOpacity>

      {customers.length === 0 ? (
        <View style={styles.emptyContainer}>
          <Text style={styles.emptyText}>Nenhum cliente cadastrado</Text>
        </View>
      ) : (
        <FlatList
          data={customers}
          renderItem={renderCustomerItem}
          keyExtractor={item => item.id?.toString() || ''}
          contentContainerStyle={styles.listContainer}
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f6fa',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  addButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#0a7ea4',
    padding: 16,
    margin: 16,
    borderRadius: 8,
  },
  addButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  listContainer: {
    padding: 16,
  },
  customerCard: {
    flexDirection: 'row',
    backgroundColor: '#FFF',
    padding: 16,
    borderRadius: 8,
    marginBottom: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  customerInfo: {
    flex: 1,
  },
  customerName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  customerDetail: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  customerActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  actionButton: {
    padding: 8,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 20,
  },
  emptyText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
});

================
File: app/screens/customers/details.tsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  ActivityIndicator
} from 'react-native';
import { useLocalSearchParams } from 'expo-router';
import { formatCurrency } from '../../../utils/format';
import { Customer } from '../../../database/customerRepository';
import { Order } from '../../../database/orderRepository';

export default function CustomerDetails() {
  const { customerId } = useLocalSearchParams();
  const [customer, setCustomer] = useState<Customer | null>(null);
  const [orders, setOrders] = useState<Order[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    loadCustomerData();
  }, [customerId]);

  const loadCustomerData = async () => {
    // Implementar carregamento dos dados do cliente e seus pedidos
    setIsLoading(false);
  };

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0a7ea4" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.customerInfo}>
        {customer && (
          <>
            <Text style={styles.customerName}>{customer.name}</Text>
            {customer.phone && (
              <Text style={styles.customerDetail}>📱 {customer.phone}</Text>
            )}
            {customer.email && (
              <Text style={styles.customerDetail}>📧 {customer.email}</Text>
            )}
          </>
        )}
      </View>

      <View style={styles.ordersList}>
        <Text style={styles.sectionTitle}>Histórico de Pedidos</Text>
        <FlatList
          data={orders}
          keyExtractor={(item) => item.id!.toString()}
          renderItem={({ item }) => (
            <TouchableOpacity style={styles.orderCard}>
              <Text style={styles.orderDate}>
                {new Date(item.created_at!).toLocaleDateString()}
              </Text>
              <Text style={styles.orderTotal}>
                {formatCurrency(item.total)}
              </Text>
            </TouchableOpacity>
          )}
          ListEmptyComponent={
            <Text style={styles.emptyText}>Nenhum pedido encontrado</Text>
          }
        />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f6fa',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  customerInfo: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 8,
  },
  customerName: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 8,
  },
  customerDetail: {
    fontSize: 16,
    color: '#666',
    marginBottom: 4,
  },
  ordersList: {
    flex: 1,
    padding: 16,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 16,
  },
  orderCard: {
    backgroundColor: '#fff',
    padding: 16,
    borderRadius: 8,
    marginBottom: 8,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  orderDate: {
    fontSize: 16,
    color: '#666',
  },
  orderTotal: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#0a7ea4',
  },
  emptyText: {
    textAlign: 'center',
    color: '#666',
    fontSize: 16,
  },
});

================
File: app/screens/customers/edit.tsx
================
import { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TextInput, 
  TouchableOpacity,
  ScrollView,
  Alert,
  ActivityIndicator
} from 'react-native';
import { customerRepository } from '../../../database/customerRepository';
import { useRouter, useLocalSearchParams } from 'expo-router';

export default function EditCustomer() {
  const router = useRouter();
  const { customerId } = useLocalSearchParams();
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [name, setName] = useState('');
  const [phone, setPhone] = useState('');
  const [email, setEmail] = useState('');
  const [address, setAddress] = useState('');
  const [notes, setNotes] = useState('');

  useEffect(() => {
    loadCustomer();
  }, [customerId]);

  const loadCustomer = async () => {
    try {
      setIsLoading(true);
      const customer = await customerRepository.findById(Number(customerId));
      if (customer) {
        setName(customer.name);
        setPhone(customer.phone || '');
        setEmail(customer.email || '');
        setAddress(customer.address || '');
        setNotes(customer.notes || '');
      }
    } catch (error) {
      console.error('Erro ao carregar cliente:', error);
      Alert.alert('Erro', 'Não foi possível carregar os dados do cliente');
    } finally {
      setIsLoading(false);
    }
  };

  const handleSubmit = async () => {
    if (isSubmitting) return;

    if (!name) {
      Alert.alert('Erro', 'Por favor, preencha o nome do cliente');
      return;
    }

    try {
      setIsSubmitting(true);
      
      await customerRepository.update(Number(customerId), {
        name,
        phone,
        email,
        address,
        notes
      });

      Alert.alert('Sucesso', 'Cliente atualizado com sucesso', [
        { 
          text: 'OK', 
          onPress: () => router.back() 
        }
      ]);
    } catch (error) {
      console.error('Erro ao atualizar cliente:', error);
      Alert.alert('Erro', 'Não foi possível atualizar o cliente');
    } finally {
      setIsSubmitting(false);
    }
  };

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0a7ea4" />
      </View>
    );
  }

  return (
    <ScrollView style={styles.container}>
      <View style={styles.form}>
        <Text style={styles.label}>Nome*</Text>
        <TextInput
          style={styles.input}
          value={name}
          onChangeText={setName}
          placeholder="Nome do cliente"
        />

        <Text style={styles.label}>Telefone</Text>
        <TextInput
          style={styles.input}
          value={phone}
          onChangeText={setPhone}
          placeholder="(00) 00000-0000"
          keyboardType="phone-pad"
        />

        <Text style={styles.label}>Email</Text>
        <TextInput
          style={styles.input}
          value={email}
          onChangeText={setEmail}
          placeholder="email@exemplo.com"
          keyboardType="email-address"
          autoCapitalize="none"
        />

        <Text style={styles.label}>Endereço</Text>
        <TextInput
          style={[styles.input, styles.textArea]}
          value={address}
          onChangeText={setAddress}
          placeholder="Endereço completo"
          multiline
          numberOfLines={3}
        />

        <Text style={styles.label}>Observações</Text>
        <TextInput
          style={[styles.input, styles.textArea]}
          value={notes}
          onChangeText={setNotes}
          placeholder="Observações sobre o cliente"
          multiline
          numberOfLines={3}
        />

        <TouchableOpacity 
          style={[styles.submitButton, isSubmitting && styles.submitButtonDisabled]}
          onPress={handleSubmit}
          disabled={isSubmitting}
        >
          {isSubmitting ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator color="#FFF" />
              <Text style={styles.loadingText}>Salvando...</Text>
            </View>
          ) : (
            <Text style={styles.submitButtonText}>Salvar Alterações</Text>
          )}
        </TouchableOpacity>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f6fa',
  },
  form: {
    padding: 16,
  },
  label: {
    fontSize: 16,
    color: '#333',
    marginBottom: 8,
    marginTop: 16,
  },
  input: {
    backgroundColor: '#FFF',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    borderWidth: 1,
    borderColor: '#DDD',
  },
  textArea: {
    height: 100,
    textAlignVertical: 'top',
  },
  submitButton: {
    backgroundColor: "#0a7ea4",
    padding: 16,
    borderRadius: 8,
    alignItems: "center",
    marginTop: 24,
    height: 50,
  },
  submitButtonDisabled: {
    backgroundColor: "#999",
  },
  submitButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    color: '#FFF',
    marginLeft: 8,
    fontSize: 16,
    fontWeight: 'bold',
  },
});

================
File: app/screens/customers/new.tsx
================
import { useState } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TextInput, 
  TouchableOpacity,
  ScrollView,
  Alert,
  ActivityIndicator
} from 'react-native';
import { customerRepository } from '../../../database/customerRepository';
import { useRouter } from 'expo-router';

export default function NewCustomer() {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [name, setName] = useState('');
  const [phone, setPhone] = useState('');
  const [email, setEmail] = useState('');
  const [address, setAddress] = useState('');
  const [notes, setNotes] = useState('');

  const handleSubmit = async () => {
    if (isSubmitting) return;

    if (!name) {
      Alert.alert('Erro', 'Por favor, preencha o nome do cliente');
      return;
    }

    try {
      setIsSubmitting(true);
      
      await customerRepository.create({
        name,
        phone,
        email,
        address,
        notes
      });

      Alert.alert('Sucesso', 'Cliente cadastrado com sucesso', [
        { 
          text: 'OK', 
          onPress: () => router.back() 
        }
      ]);
    } catch (error) {
      console.error('Erro ao criar cliente:', error);
      Alert.alert('Erro', 'Não foi possível cadastrar o cliente');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <ScrollView style={styles.container}>
      <View style={styles.form}>
        <Text style={styles.label}>Nome*</Text>
        <TextInput
          style={styles.input}
          value={name}
          onChangeText={setName}
          placeholder="Nome do cliente"
        />

        <Text style={styles.label}>Telefone</Text>
        <TextInput
          style={styles.input}
          value={phone}
          onChangeText={setPhone}
          placeholder="(00) 00000-0000"
          keyboardType="phone-pad"
        />

        <Text style={styles.label}>Email</Text>
        <TextInput
          style={styles.input}
          value={email}
          onChangeText={setEmail}
          placeholder="email@exemplo.com"
          keyboardType="email-address"
          autoCapitalize="none"
        />

        <Text style={styles.label}>Endereço</Text>
        <TextInput
          style={[styles.input, styles.textArea]}
          value={address}
          onChangeText={setAddress}
          placeholder="Endereço completo"
          multiline
          numberOfLines={3}
        />

        <Text style={styles.label}>Observações</Text>
        <TextInput
          style={[styles.input, styles.textArea]}
          value={notes}
          onChangeText={setNotes}
          placeholder="Observações sobre o cliente"
          multiline
          numberOfLines={3}
        />

        <TouchableOpacity 
          style={[styles.submitButton, isSubmitting && styles.submitButtonDisabled]}
          onPress={handleSubmit}
          disabled={isSubmitting}
        >
          {isSubmitting ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator color="#FFF" />
              <Text style={styles.loadingText}>Salvando...</Text>
            </View>
          ) : (
            <Text style={styles.submitButtonText}>Cadastrar Cliente</Text>
          )}
        </TouchableOpacity>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f6fa',
  },
  form: {
    padding: 16,
  },
  label: {
    fontSize: 16,
    color: '#333',
    marginBottom: 8,
    marginTop: 16,
  },
  input: {
    backgroundColor: '#FFF',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    borderWidth: 1,
    borderColor: '#DDD',
  },
  textArea: {
    height: 100,
    textAlignVertical: 'top',
  },
  submitButton: {
    backgroundColor: "#0a7ea4",
    padding: 16,
    borderRadius: 8,
    alignItems: "center",
    marginTop: 24,
    height: 50,
  },
  submitButtonDisabled: {
    backgroundColor: "#999",
  },
  submitButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  loadingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    color: '#FFF',
    marginLeft: 8,
    fontSize: 16,
    fontWeight: 'bold',
  },
});

================
File: app/screens/home.tsx
================
import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  TouchableOpacity,
  ActivityIndicator
} from 'react-native';
import { useRouter } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import { formatCurrency } from '../../utils/format';
import { useAuth } from '../../contexts/AuthContext';
import { orderRepository } from '../../database/orderRepository';
import { cashRepository } from '../../database/cashRepository';
import { getDatabase } from '../../database/database';
import { useFocusEffect } from 'expo-router';
import { useCallback } from 'react';

interface DashboardCardProps {
  title: string;
  value: string;
  icon: keyof typeof Ionicons.glyphMap;
  color: string;
}

interface DashboardData {
  todaySales: number;
  pendingOrders: number;
  cashBalance: number | null;
  totalOrders: number;
}

interface MenuItemProps {
  icon: keyof typeof Ionicons.glyphMap;
  label: string;
  onPress: () => void;
  color?: string;
}

function MenuItem({ icon, label, onPress, color = '#0a7ea4' }: MenuItemProps) {
  return (
    <TouchableOpacity style={styles.menuItem} onPress={onPress}>
      <View style={[styles.menuIconContainer, { backgroundColor: color }]}>
        <Ionicons name={icon} size={24} color="#FFF" />
      </View>
      <Text style={styles.menuLabel}>{label}</Text>
    </TouchableOpacity>
  );
}

function DashboardCard({ title, value, icon, color }: DashboardCardProps) {
  return (
    <View style={[styles.dashboardCard, { borderLeftColor: color }]}>
      <Ionicons name={icon} size={24} color={color} />
      <Text style={styles.cardTitle}>{title}</Text>
      <Text style={[styles.cardValue, { color }]}>{value}</Text>
    </View>
  );
}

export default function Home() {
  const router = useRouter();
  const { user } = useAuth();
  const [isLoading, setIsLoading] = useState(true);
  const [dashboardData, setDashboardData] = useState<DashboardData>({
    todaySales: 0,
    pendingOrders: 0,
    cashBalance: null,
    totalOrders: 0
  });

  useFocusEffect(
    useCallback(() => {
      const initApp = async () => {
        try {
          const db = getDatabase();
          if (!db) {
            console.log('Aguardando inicialização do banco de dados...');
            return;
          }
          
          await loadDashboardData();
        } catch (error) {
          console.error('Erro na inicialização:', error);
        }
      };

      initApp();
    }, [])
  );

  const loadDashboardData = async () => {
    try {
      setIsLoading(true);
      
      // Carregar dados do caixa
      const cashStatus = await cashRepository.getCurrentStatus();
      
      // Carregar dados dos pedidos
      const today = new Date().toISOString().split('T')[0];
      const orders = await orderRepository.findAll();
      
      const todayOrders = orders.filter(order => 
        order.created_at?.startsWith(today)
      );
      
      const pendingOrders = orders.filter(order => 
        order.status === 'pending' || order.status === 'preparing'
      );

      setDashboardData({
        todaySales: todayOrders.reduce((sum, order) => sum + order.total, 0),
        pendingOrders: pendingOrders.length,
        cashBalance: cashStatus?.current_amount ?? null,
        totalOrders: orders.length
      });
    } catch (error) {
      console.error('Erro ao carregar dashboard:', error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.headerTitle}>Lanchonete App</Text>
        <TouchableOpacity onPress={() => router.push('screens/profile' as any)}>
          <Ionicons name="person-circle-outline" size={32} color="#0a7ea4" />
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.content}>
        {isLoading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color="#0a7ea4" />
          </View>
        ) : (
          <>
            <View style={styles.dashboardGrid}>
              <DashboardCard
                title="Vendas Hoje"
                value={formatCurrency(dashboardData.todaySales)}
                icon="cash-outline"
                color="#27ae60"
              />
              <DashboardCard
                title="Pedidos Pendentes"
                value={dashboardData.pendingOrders.toString()}
                icon="time-outline"
                color="#e67e22"
              />
              {dashboardData.cashBalance !== null && (
                <DashboardCard
                  title="Saldo em Caixa"
                  value={formatCurrency(dashboardData.cashBalance)}
                  icon="wallet-outline"
                  color="#0a7ea4"
                />
              )}
              <DashboardCard
                title="Total de Pedidos"
                value={dashboardData.totalOrders.toString()}
                icon="receipt-outline"
                color="#8e44ad"
              />
            </View>

            <View style={styles.menuGrid}>
              <MenuItem
                icon="cart-outline"
                label="Nova Venda"
                onPress={() => router.push('screens/sales/new' as any)}
                color="#2ecc71"
              />
              <MenuItem
                icon="list-outline"
                label="Pedidos"
                onPress={() => router.push('screens/orders' as any)}
              />
              <MenuItem
                icon="cube-outline"
                label="Produtos"
                onPress={() => router.push('screens/products' as any)}
              />
              <MenuItem
                icon="people-outline"
                label="Clientes"
                onPress={() => router.push('screens/customers' as any)}
              />
              <MenuItem
                icon="bar-chart-outline"
                label="Relatórios"
                onPress={() => router.push('screens/reports' as any)}
              />
              <MenuItem
                icon="settings-outline"
                label="Configurações"
                onPress={() => router.push('screens/settings' as any)}
              />
              <MenuItem
                icon="people"
                label="Usuários"
                onPress={() => router.push('screens/users' as any)}
              />
              <MenuItem
                icon="calculator-outline"
                label="Caixa"
                onPress={() => router.push('screens/cashier' as any)}
                color="#e74c3c"
              />
            </View>
          </>
        )}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f6fa',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 16,
    backgroundColor: '#FFF',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
  },
  content: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingTop: 50,
  },
  dashboardGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    padding: 8,
  },
  dashboardCard: {
    backgroundColor: '#FFF',
    padding: 16,
    margin: 8,
    borderRadius: 8,
    borderLeftWidth: 4,
    width: '45%',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  cardTitle: {
    fontSize: 14,
    color: '#666',
    marginTop: 8,
  },
  cardValue: {
    fontSize: 20,
    fontWeight: 'bold',
    marginTop: 4,
  },
  menuGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    padding: 8,
    justifyContent: 'space-between',
  },
  menuItem: {
    width: '45%',
    backgroundColor: '#FFF',
    padding: 16,
    margin: 8,
    borderRadius: 8,
    alignItems: 'center',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  menuIconContainer: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: '#0a7ea4',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 8,
  },
  menuLabel: {
    fontSize: 14,
    color: '#333',
    textAlign: 'center',
  },
});

================
File: app/screens/orders.tsx
================
import { useState, useCallback } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  FlatList, 
  TouchableOpacity, 
  ActivityIndicator 
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { orderRepository, Order } from '../../database/orderRepository';
import { useFocusEffect } from 'expo-router';
import { formatCurrency } from '../../utils/format';

const STATUS_COLORS = {
  pending: '#f1c40f',     // Amarelo
  preparing: '#3498db',   // Azul
  ready: '#2ecc71',       // Verde
  delivered: '#95a5a6',   // Cinza
  cancelled: '#e74c3c'    // Vermelho
};

const STATUS_LABELS = {
  pending: 'Pendente',
  preparing: 'Preparando',
  ready: 'Pronto',
  delivered: 'Entregue',
  cancelled: 'Cancelado'
};

export default function Orders() {
  const [orders, setOrders] = useState<Order[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  const loadOrders = useCallback(async () => {
    try {
      setIsLoading(true);
      const ordersList = await orderRepository.findAll();
      setOrders(ordersList);
    } catch (error) {
      console.error('Erro ao carregar pedidos:', error);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useFocusEffect(
    useCallback(() => {
      loadOrders();
    }, [loadOrders])
  );

  const handleUpdateStatus = async (orderId: number, newStatus: Order['status']) => {
    try {
      await orderRepository.updateStatus(orderId, newStatus);
      loadOrders();
    } catch (error) {
      console.error('Erro ao atualizar status:', error);
    }
  };

  const getNextStatus = (currentStatus: Order['status']): Order['status'] | null => {
    const statusFlow = {
      pending: 'preparing',
      preparing: 'ready',
      ready: 'delivered',
      delivered: null,
      cancelled: null
    };
    return statusFlow[currentStatus] as Order['status'] | null;
  };

  const renderOrderItem = ({ item }: { item: Order }) => (
    <View style={styles.orderCard}>
      <View style={styles.orderHeader}>
        <View>
          <Text style={styles.orderNumber}>Pedido #{item.id}</Text>
          {item.customer_name && (
            <Text style={styles.customerName}>Cliente: {item.customer_name}</Text>
          )}
          {item.table_number && (
            <Text style={styles.tableNumber}>Mesa: {item.table_number}</Text>
          )}
        </View>
        <View style={[styles.statusBadge, { backgroundColor: STATUS_COLORS[item.status] }]}>
          <Text style={styles.statusText}>{STATUS_LABELS[item.status]}</Text>
        </View>
      </View>

      <View style={styles.itemsList}>
        {item.items.map((orderItem, index) => (
          <View key={index} style={styles.orderItem}>
            <Text style={styles.itemQuantity}>{orderItem.quantity}x</Text>
            <Text style={styles.itemName}>{orderItem.product?.name}</Text>
            <Text style={styles.itemPrice}>
              {formatCurrency(orderItem.unit_price * orderItem.quantity)}
            </Text>
          </View>
        ))}
      </View>

      <View style={styles.orderFooter}>
        <Text style={styles.totalText}>Total: {formatCurrency(item.total)}</Text>
        {item.status !== 'delivered' && item.status !== 'cancelled' && (
          <View style={styles.actionButtons}>
            <TouchableOpacity 
              style={[styles.actionButton, { backgroundColor: STATUS_COLORS[item.status] }]}
              onPress={() => {
                const nextStatus = getNextStatus(item.status);
                if (nextStatus) {
                  handleUpdateStatus(item.id!, nextStatus);
                }
              }}
            >
              <Text style={styles.actionButtonText}>
                {item.status === 'pending' ? 'Preparar' :
                 item.status === 'preparing' ? 'Pronto' :
                 item.status === 'ready' ? 'Entregar' : ''}
              </Text>
            </TouchableOpacity>
            
            {item.status === 'pending' && (
              <TouchableOpacity 
                style={[styles.actionButton, { backgroundColor: STATUS_COLORS.cancelled }]}
                onPress={() => handleUpdateStatus(item.id!, 'cancelled')}
              >
                <Text style={styles.actionButtonText}>Cancelar</Text>
              </TouchableOpacity>
            )}
          </View>
        )}
      </View>
    </View>
  );

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0a7ea4" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {orders.length === 0 ? (
        <View style={styles.emptyContainer}>
          <Text style={styles.emptyText}>Nenhum pedido encontrado</Text>
        </View>
      ) : (
        <FlatList
          data={orders}
          renderItem={renderOrderItem}
          keyExtractor={item => item.id!.toString()}
          contentContainerStyle={styles.listContainer}
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f6fa',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  emptyText: {
    fontSize: 16,
    color: '#666',
  },
  listContainer: {
    padding: 16,
  },
  orderCard: {
    backgroundColor: '#FFF',
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  orderHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  orderNumber: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  customerName: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  tableNumber: {
    fontSize: 14,
    color: '#666',
  },
  statusBadge: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
  },
  statusText: {
    color: '#FFF',
    fontSize: 12,
    fontWeight: 'bold',
  },
  itemsList: {
    borderTopWidth: 1,
    borderTopColor: '#EEE',
    paddingTop: 16,
  },
  orderItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  itemQuantity: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#666',
    width: 40,
  },
  itemName: {
    flex: 1,
    fontSize: 14,
    color: '#333',
  },
  itemPrice: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#0a7ea4',
  },
  orderFooter: {
    marginTop: 16,
    borderTopWidth: 1,
    borderTopColor: '#EEE',
    paddingTop: 16,
  },
  totalText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 16,
  },
  actionButtons: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 8,
  },
  actionButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 4,
  },
  actionButtonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: 'bold',
  },
});

================
File: app/screens/products.tsx
================
import { useState, useCallback } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  FlatList, 
  TouchableOpacity, 
  ActivityIndicator,
  Image
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { productRepository, Product } from '../../database/productRepository';
import { useRouter, useFocusEffect } from 'expo-router';
import { formatCurrency } from '../../utils/format';

export default function Products() {
  const [products, setProducts] = useState<Product[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const router = useRouter();

  const loadProducts = useCallback(async () => {
    try {
      setIsLoading(true);
      const productsList = await productRepository.findAll();
      setProducts(productsList);
    } catch (error) {
      console.error('Erro ao carregar produtos:', error);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useFocusEffect(
    useCallback(() => {
      loadProducts();
    }, [loadProducts])
  );

  const handleDeactivateProduct = async (productId: number) => {
    try {
      await productRepository.deactivate(productId);
      loadProducts();
    } catch (error) {
      console.error('Erro ao desativar produto:', error);
    }
  };

  const renderProductItem = ({ item }: { item: Product }) => (
    <View style={styles.productCard}>
      {item.image ? (
        <Image source={{ uri: item.image }} style={styles.productImage} />
      ) : (
        <View style={styles.placeholderImage}>
          <Ionicons name="fast-food-outline" size={32} color="#999" />
        </View>
      )}
      
      <View style={styles.productInfo}>
        <Text style={styles.productName}>{item.name}</Text>
        <Text style={styles.productCategory}>{item.category}</Text>
        <Text style={styles.productPrice}>{formatCurrency(item.price)}</Text>
      </View>

      <View style={styles.productActions}>
        <TouchableOpacity 
          onPress={() => router.push({
            pathname: 'screens/products/edit',
            params: { productId: item.id }
          } as any)}
          style={styles.actionButton}
        >
          <Ionicons name="create-outline" size={24} color="#0a7ea4" />
        </TouchableOpacity>
        <TouchableOpacity 
          onPress={() => handleDeactivateProduct(item.id!)}
          style={styles.actionButton}
        >
          <Ionicons name="trash-outline" size={24} color="#e74c3c" />
        </TouchableOpacity>
      </View>
    </View>
  );

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0a7ea4" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <TouchableOpacity 
        style={styles.addButton}
        onPress={() => router.push('screens/products/new' as any)}
      >
        <Ionicons name="add" size={24} color="#FFF" />
        <Text style={styles.addButtonText}>Novo Produto</Text>
      </TouchableOpacity>

      {products.length === 0 ? (
        <View style={styles.emptyContainer}>
          <Text style={styles.emptyText}>Nenhum produto cadastrado</Text>
        </View>
      ) : (
        <FlatList
          data={products}
          renderItem={renderProductItem}
          keyExtractor={item => item.id?.toString() || ''}
          contentContainerStyle={styles.listContainer}
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f6fa',
    padding: 16,
  },
  addButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#0a7ea4',
    padding: 12,
    borderRadius: 8,
    marginBottom: 16,
  },
  addButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  productCard: {
    flexDirection: 'row',
    backgroundColor: '#FFF',
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    alignItems: 'center',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  productImage: {
    width: 60,
    height: 60,
    borderRadius: 8,
    marginRight: 16,
  },
  placeholderImage: {
    width: 60,
    height: 60,
    borderRadius: 8,
    marginRight: 16,
    backgroundColor: '#f5f6fa',
    alignItems: 'center',
    justifyContent: 'center',
  },
  productInfo: {
    flex: 1,
  },
  productName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  productCategory: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  productPrice: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#0a7ea4',
    marginTop: 4,
  },
  productActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  actionButton: {
    padding: 8,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  emptyText: {
    fontSize: 16,
    color: '#666',
  },
  listContainer: {
    flexGrow: 1,
  },
});

================
File: app/screens/products/edit.tsx
================
import { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TextInput, 
  TouchableOpacity,
  ScrollView,
  Alert,
  ActivityIndicator
} from 'react-native';
import { productRepository } from '../../../database/productRepository';
import { useRouter, useLocalSearchParams } from 'expo-router';

export default function EditProduct() {
  const router = useRouter();
  const { productId } = useLocalSearchParams();
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [price, setPrice] = useState('');
  const [category, setCategory] = useState('');

  useEffect(() => {
    loadProduct();
  }, [productId]);

  const loadProduct = async () => {
    try {
      setIsLoading(true);
      const product = await productRepository.findById(Number(productId));
      if (product) {
        setName(product.name);
        setDescription(product.description || '');
        setPrice(product.price.toString().replace('.', ','));
        setCategory(product.category);
      }
    } catch (error) {
      console.error('Erro ao carregar produto:', error);
      Alert.alert('Erro', 'Não foi possível carregar os dados do produto');
    } finally {
      setIsLoading(false);
    }
  };

  const handleSubmit = async () => {
    if (isSubmitting) return;

    if (!name || !price || !category) {
      Alert.alert('Erro', 'Por favor, preencha todos os campos obrigatórios');
      return;
    }

    try {
      setIsSubmitting(true);
      
      await productRepository.update(Number(productId), {
        name,
        description,
        price: Number(price.replace(',', '.')),
        category,
      });

      Alert.alert('Sucesso', 'Produto atualizado com sucesso', [
        { 
          text: 'OK', 
          onPress: () => router.back() 
        }
      ]);
    } catch (error) {
      console.error('Erro ao atualizar produto:', error);
      Alert.alert('Erro', 'Não foi possível atualizar o produto');
    } finally {
      setIsSubmitting(false);
    }
  };

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0a7ea4" />
      </View>
    );
  }

  return (
    <ScrollView style={styles.container}>
      <View style={styles.form}>
        <Text style={styles.label}>Nome*</Text>
        <TextInput
          style={styles.input}
          value={name}
          onChangeText={setName}
          placeholder="Nome do produto"
        />

        <Text style={styles.label}>Descrição</Text>
        <TextInput
          style={[styles.input, styles.textArea]}
          value={description}
          onChangeText={setDescription}
          placeholder="Descrição do produto"
          multiline
          numberOfLines={4}
        />

        <Text style={styles.label}>Preço*</Text>
        <TextInput
          style={styles.input}
          value={price}
          onChangeText={setPrice}
          placeholder="0,00"
          keyboardType="decimal-pad"
        />

        <Text style={styles.label}>Categoria*</Text>
        <TextInput
          style={styles.input}
          value={category}
          onChangeText={setCategory}
          placeholder="Categoria do produto"
        />

        <TouchableOpacity 
          style={[styles.submitButton, isSubmitting && styles.submitButtonDisabled]}
          onPress={handleSubmit}
          disabled={isSubmitting}
        >
          {isSubmitting ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator color="#FFF" />
              <Text style={styles.loadingText}>Salvando...</Text>
            </View>
          ) : (
            <Text style={styles.submitButtonText}>Salvar Alterações</Text>
          )}
        </TouchableOpacity>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f6fa',
  },
  form: {
    padding: 16,
  },
  label: {
    fontSize: 16,
    color: '#333',
    marginBottom: 8,
    marginTop: 16,
  },
  input: {
    backgroundColor: '#FFF',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    borderWidth: 1,
    borderColor: '#DDD',
  },
  textArea: {
    height: 100,
    textAlignVertical: 'top',
  },
  submitButton: {
    backgroundColor: "#0a7ea4",
    padding: 16,
    borderRadius: 8,
    alignItems: "center",
    marginTop: 24,
    height: 50,
  },
  submitButtonDisabled: {
    backgroundColor: "#999",
  },
  submitButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  loadingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    color: '#FFF',
    marginLeft: 8,
    fontSize: 16,
    fontWeight: 'bold',
  },
});

================
File: app/screens/products/new.tsx
================
import { useState } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TextInput, 
  TouchableOpacity,
  ScrollView,
  Alert,
  ActivityIndicator
} from 'react-native';
import { productRepository } from '../../../database/productRepository';
import { useRouter } from 'expo-router';

export default function NewProduct() {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [price, setPrice] = useState('');
  const [category, setCategory] = useState('');

  const handleSubmit = async () => {
    if (isSubmitting) return;

    if (!name || !price || !category) {
      Alert.alert('Erro', 'Por favor, preencha todos os campos obrigatórios');
      return;
    }

    try {
      setIsSubmitting(true);
      
      await productRepository.create({
        name,
        description,
        price: Number(price.replace(',', '.')),
        category,
      });

      Alert.alert('Sucesso', 'Produto criado com sucesso', [
        { 
          text: 'OK', 
          onPress: () => router.back() 
        }
      ]);
    } catch (error) {
      console.error('Erro ao criar produto:', error);
      Alert.alert('Erro', 'Não foi possível criar o produto');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <ScrollView style={styles.container}>
      <View style={styles.form}>
        <Text style={styles.label}>Nome*</Text>
        <TextInput
          style={styles.input}
          value={name}
          onChangeText={setName}
          placeholder="Nome do produto"
        />

        <Text style={styles.label}>Descrição</Text>
        <TextInput
          style={[styles.input, styles.textArea]}
          value={description}
          onChangeText={setDescription}
          placeholder="Descrição do produto"
          multiline
          numberOfLines={4}
        />

        <Text style={styles.label}>Preço*</Text>
        <TextInput
          style={styles.input}
          value={price}
          onChangeText={setPrice}
          placeholder="0,00"
          keyboardType="decimal-pad"
        />

        <Text style={styles.label}>Categoria*</Text>
        <TextInput
          style={styles.input}
          value={category}
          onChangeText={setCategory}
          placeholder="Categoria do produto"
        />

        <TouchableOpacity 
          style={[styles.submitButton, isSubmitting && styles.submitButtonDisabled]}
          onPress={handleSubmit}
          disabled={isSubmitting}
        >
          {isSubmitting ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator color="#FFF" />
              <Text style={styles.loadingText}>Salvando...</Text>
            </View>
          ) : (
            <Text style={styles.submitButtonText}>Criar Produto</Text>
          )}
        </TouchableOpacity>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f6fa',
  },
  form: {
    padding: 16,
  },
  label: {
    fontSize: 16,
    color: '#333',
    marginBottom: 8,
    marginTop: 16,
  },
  input: {
    backgroundColor: '#FFF',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    borderWidth: 1,
    borderColor: '#DDD',
  },
  textArea: {
    height: 100,
    textAlignVertical: 'top',
  },
  submitButton: {
    backgroundColor: "#0a7ea4",
    padding: 16,
    borderRadius: 8,
    alignItems: "center",
    marginTop: 24,
    height: 50,
  },
  submitButtonDisabled: {
    backgroundColor: "#999",
  },
  submitButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  loadingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    color: '#FFF',
    marginLeft: 8,
    fontSize: 16,
    fontWeight: 'bold',
  },
});

================
File: app/screens/profile.tsx
================
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { useAuth } from '../../contexts/AuthContext';
import { useRouter } from 'expo-router';

export default function Profile() {
  const { user, signOut } = useAuth();
  const router = useRouter();

  const handleLogout = async () => {
    await signOut();
    router.replace('/');
  };

  return (
    <View style={styles.container}>
      <Text style={styles.name}>{user?.name}</Text>
      <Text style={styles.username}>@{user?.username}</Text>
      
      <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
        <Text style={styles.logoutText}>Sair</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    padding: 20,
    backgroundColor: '#fff',
  },
  name: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
    marginTop: 20,
  },
  username: {
    fontSize: 16,
    color: '#666',
    marginTop: 8,
  },
  logoutButton: {
    backgroundColor: '#e74c3c',
    padding: 16,
    borderRadius: 8,
    marginTop: 40,
    width: '100%',
    alignItems: 'center',
  },
  logoutText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
});

================
File: app/screens/reports.tsx
================
import React, { useState, useCallback, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { formatCurrency, formatDate } from '../../utils/format';
import { orderRepository } from '../../database/orderRepository';
import { cashRepository } from '../../database/cashRepository';

interface TopProduct {
  id: number;
  name: string;
  quantity: number;
  total: number;
}

interface ReportData {
  totalSales: number;
  totalOrders: number;
  averageTicket: number;
  topProducts: TopProduct[];
  cashMovements: {
    inflow: number;
    outflow: number;
    balance: number;
  };
}

export default function Reports() {
  const [isLoading, setIsLoading] = useState(false);
  const [startDate, setStartDate] = useState(new Date());
  const [endDate, setEndDate] = useState(new Date());
  const [reportData, setReportData] = useState<ReportData>({
    totalSales: 0,
    totalOrders: 0,
    averageTicket: 0,
    topProducts: [],
    cashMovements: {
      inflow: 0,
      outflow: 0,
      balance: 0
    }
  });

  const loadReport = useCallback(async () => {
    try {
      setIsLoading(true);

      // Buscar todos os pedidos do período
      const orders = await orderRepository.findAll();
      const startDateTime = startDate.setHours(0, 0, 0, 0);
      const endDateTime = endDate.setHours(23, 59, 59, 999);

      // Filtrar pedidos do período
      const filteredOrders = orders.filter(order => {
        const orderDate = new Date(order.created_at!).getTime();
        return orderDate >= startDateTime && orderDate <= endDateTime;
      });

      // Calcular totais
      const totalSales = filteredOrders.reduce((sum, order) => sum + order.total, 0);
      const totalOrders = filteredOrders.length;
      const averageTicket = totalOrders > 0 ? totalSales / totalOrders : 0;

      // Calcular produtos mais vendidos
      const productsMap = new Map<number, TopProduct>();
      
      filteredOrders.forEach(order => {
        order.items.forEach(item => {
          const existing = productsMap.get(item.product_id);
          if (existing) {
            existing.quantity += item.quantity;
            existing.total += item.quantity * item.unit_price;
          } else {
            productsMap.set(item.product_id, {
              id: item.product_id,
              name: item.product?.name || 'Produto não encontrado',
              quantity: item.quantity,
              total: item.quantity * item.unit_price
            });
          }
        });
      });

      const topProducts = Array.from(productsMap.values())
        .sort((a, b) => b.total - a.total)
        .slice(0, 5);

      // Buscar movimentações do caixa
      const movements = await cashRepository.getMovements(
        startDate.toISOString().split('T')[0]
      );

      const cashMovements = movements.reduce(
        (acc, movement) => {
          if (['sale', 'deposit'].includes(movement.type)) {
            acc.inflow += movement.amount;
          } else if (['withdrawal', 'expense'].includes(movement.type)) {
            acc.outflow += movement.amount;
          }
          return acc;
        },
        { inflow: 0, outflow: 0, balance: 0 }
      );

      cashMovements.balance = cashMovements.inflow - cashMovements.outflow;

      setReportData({
        totalSales,
        totalOrders,
        averageTicket,
        topProducts,
        cashMovements
      });

    } catch (error) {
      console.error('Erro ao carregar relatório:', error);
    } finally {
      setIsLoading(false);
    }
  }, [startDate, endDate]);

  useEffect(() => {
    loadReport();
  }, [loadReport]);

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0a7ea4" />
      </View>
    );
  }

  return (
    <ScrollView style={styles.container}>
      <View style={styles.dateFilters}>
        <Text style={styles.dateLabel}>Período: {formatDate(startDate)} - {formatDate(endDate)}</Text>
      </View>

      <View style={styles.reportCard}>
        <Text style={styles.cardTitle}>Resumo de Vendas</Text>
        <Text style={styles.cardValue}>{formatCurrency(reportData.totalSales)}</Text>
        <Text style={styles.cardSubtitle}>{reportData.totalOrders} pedidos</Text>
        <Text style={styles.cardSubtitle}>
          Ticket Médio: {formatCurrency(reportData.averageTicket)}
        </Text>
      </View>

      <View style={styles.reportCard}>
        <Text style={styles.cardTitle}>Movimentação do Caixa</Text>
        <View style={styles.cashMovements}>
          <View style={styles.cashMovementItem}>
            <Ionicons name="arrow-up-circle" size={24} color="#27ae60" />
            <Text style={styles.movementLabel}>Entradas</Text>
            <Text style={[styles.movementValue, { color: '#27ae60' }]}>
              {formatCurrency(reportData.cashMovements.inflow)}
            </Text>
          </View>
          <View style={styles.cashMovementItem}>
            <Ionicons name="arrow-down-circle" size={24} color="#e74c3c" />
            <Text style={styles.movementLabel}>Saídas</Text>
            <Text style={[styles.movementValue, { color: '#e74c3c' }]}>
              {formatCurrency(reportData.cashMovements.outflow)}
            </Text>
          </View>
          <View style={styles.cashMovementItem}>
            <Ionicons name="wallet" size={24} color="#0a7ea4" />
            <Text style={styles.movementLabel}>Saldo</Text>
            <Text style={[styles.movementValue, { color: '#0a7ea4' }]}>
              {formatCurrency(reportData.cashMovements.balance)}
            </Text>
          </View>
        </View>
      </View>

      <View style={styles.reportCard}>
        <Text style={styles.cardTitle}>Produtos Mais Vendidos</Text>
        {reportData.topProducts.map((product, index) => (
          <View key={product.id} style={styles.productItem}>
            <Text style={styles.productRank}>#{index + 1}</Text>
            <View style={styles.productInfo}>
              <Text style={styles.productName}>{product.name}</Text>
              <Text style={styles.productQuantity}>{product.quantity} unidades</Text>
            </View>
            <Text style={styles.productTotal}>{formatCurrency(product.total)}</Text>
          </View>
        ))}
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f6fa',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  dateFilters: {
    padding: 16,
    backgroundColor: '#fff',
    marginBottom: 8,
  },
  dateLabel: {
    fontSize: 16,
    color: '#666',
  },
  reportCard: {
    backgroundColor: '#fff',
    padding: 16,
    marginHorizontal: 16,
    marginBottom: 16,
    borderRadius: 8,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  cardTitle: {
    fontSize: 16,
    color: '#666',
    marginBottom: 8,
  },
  cardValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#0a7ea4',
    marginBottom: 4,
  },
  cardSubtitle: {
    fontSize: 14,
    color: '#999',
  },
  cashMovements: {
    marginTop: 8,
  },
  cashMovementItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  movementLabel: {
    fontSize: 14,
    color: '#666',
    marginLeft: 8,
    flex: 1,
  },
  movementValue: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  productItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  productRank: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#666',
    width: 40,
  },
  productInfo: {
    flex: 1,
  },
  productName: {
    fontSize: 14,
    color: '#333',
  },
  productQuantity: {
    fontSize: 12,
    color: '#666',
  },
  productTotal: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#0a7ea4',
  },
});

================
File: app/screens/sales/new.tsx
================
import React, { useState, useCallback, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  FlatList, 
  TouchableOpacity, 
  TextInput,
  Alert,
  ActivityIndicator
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { productRepository, Product } from '../../../database/productRepository';
import { orderRepository, Order } from '../../../database/orderRepository';
import { formatCurrency } from '../../../utils/format';
import { useAuth } from '../../contexts/AuthContext';
import { CustomerAutocomplete } from '../../components/CustomerAutocomplete';
import { Customer } from '../../../database/customerRepository';
import { cashRepository } from '../../../database/cashRepository';

interface CartItem extends Product {
  quantity: number;
  notes?: string;
}

export default function NewSale() {
  const router = useRouter();
  const { user } = useAuth();
  const [products, setProducts] = useState<Product[]>([]);
  const [cartItems, setCartItems] = useState<CartItem[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [selectedCustomer, setSelectedCustomer] = useState<Customer | null>(null);
  const [customerName, setCustomerName] = useState('');
  const [tableNumber, setTableNumber] = useState('');
  const [searchQuery, setSearchQuery] = useState('');

  const loadProducts = useCallback(async () => {
    try {
      setIsLoading(true);
      const productsList = await productRepository.findAll();
      setProducts(productsList);
    } catch (error) {
      console.error('Erro ao carregar produtos:', error);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    loadProducts();
  }, [loadProducts]);

  const filteredProducts = products.filter(product => 
    product.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    product.category.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const addToCart = (product: Product) => {
    setCartItems(prevItems => {
      const existingItem = prevItems.find(item => item.id === product.id);
      if (existingItem) {
        return prevItems.map(item =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        );
      }
      return [...prevItems, { ...product, quantity: 1 }];
    });
  };

  const removeFromCart = (productId: number) => {
    setCartItems(prevItems => prevItems.filter(item => item.id !== productId));
  };

  const updateQuantity = (productId: number, quantity: number) => {
    if (quantity < 1) return;
    setCartItems(prevItems =>
      prevItems.map(item =>
        item.id === productId ? { ...item, quantity } : item
      )
    );
  };

  const getTotal = () => {
    return cartItems.reduce((total, item) => total + (item.price * item.quantity), 0);
  };

  const handleSubmit = async () => {
    if (isSubmitting) return;

    if (cartItems.length === 0) {
      Alert.alert('Erro', 'Adicione pelo menos um item ao pedido');
      return;
    }

    if (!user?.id) {
      Alert.alert('Erro', 'Usuário não identificado');
      return;
    }

    try {
      setIsSubmitting(true);

      const cashStatus = await cashRepository.getCurrentStatus();
      if (!cashStatus?.is_open) {
        Alert.alert('Erro', 'O caixa precisa estar aberto para registrar vendas');
        return;
      }
      
      const total = getTotal();
      
      const newOrder = {
        customer_id: selectedCustomer?.id || null,
        user_id: user.id,
        table_number: tableNumber,
        status: 'pending',
        total,
        items: cartItems.map(item => ({
          product_id: item.id!,
          quantity: item.quantity,
          unit_price: item.price
        }))
      };

      console.log('Criando pedido:', newOrder);
      const orderId = await orderRepository.create(newOrder);
      console.log('Pedido criado com ID:', orderId);

      Alert.alert('Sucesso', 'Pedido criado com sucesso', [
        { 
          text: 'OK', 
          onPress: () => router.back() 
        }
      ]);
    } catch (error) {
      console.error('Erro ao criar pedido:', error);
      if (error instanceof Error) {
        Alert.alert('Erro', error.message);
      } else {
        Alert.alert('Erro', 'Não foi possível criar o pedido');
      }
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleCustomerSelect = (customer: Customer) => {
    setSelectedCustomer(customer);
    setCustomerName(customer.name);
  };

  const renderProductItem = ({ item }: { item: Product }) => (
    <TouchableOpacity 
      style={styles.productCard}
      onPress={() => addToCart(item)}
    >
      <Text style={styles.productName}>{item.name}</Text>
      <Text style={styles.productCategory}>{item.category}</Text>
      <Text style={styles.productPrice}>{formatCurrency(item.price)}</Text>
    </TouchableOpacity>
  );

  const renderCartItem = ({ item }: { item: CartItem }) => (
    <View style={styles.cartItem}>
      <View style={styles.cartItemInfo}>
        <Text style={styles.cartItemName}>{item.name}</Text>
        <Text style={styles.cartItemPrice}>{formatCurrency(item.price * item.quantity)}</Text>
      </View>
      
      <View style={styles.cartItemActions}>
        <TouchableOpacity onPress={() => updateQuantity(item.id!, item.quantity - 1)}>
          <Ionicons name="remove-circle-outline" size={24} color="#e74c3c" />
        </TouchableOpacity>
        
        <Text style={styles.cartItemQuantity}>{item.quantity}</Text>
        
        <TouchableOpacity onPress={() => updateQuantity(item.id!, item.quantity + 1)}>
          <Ionicons name="add-circle-outline" size={24} color="#2ecc71" />
        </TouchableOpacity>
        
        <TouchableOpacity onPress={() => removeFromCart(item.id!)}>
          <Ionicons name="trash-outline" size={24} color="#e74c3c" />
        </TouchableOpacity>
      </View>
    </View>
  );

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0a7ea4" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.customerInfo}>
        <CustomerAutocomplete
          value={customerName}
          onChangeText={setCustomerName}
          onSelect={handleCustomerSelect}
        />
        <TextInput
          style={[styles.input, styles.tableInput]}
          placeholder="Mesa"
          value={tableNumber}
          onChangeText={setTableNumber}
          keyboardType="numeric"
        />
      </View>

      <TextInput
        style={styles.searchInput}
        placeholder="Buscar produtos..."
        value={searchQuery}
        onChangeText={setSearchQuery}
      />

      <View style={styles.content}>
        <View style={styles.productsContainer}>
          <FlatList
            data={filteredProducts}
            renderItem={renderProductItem}
            keyExtractor={item => item.id!.toString()}
            numColumns={2}
            columnWrapperStyle={styles.productRow}
          />
        </View>

        <View style={styles.cartContainer}>
          <Text style={styles.cartTitle}>Pedido</Text>
          <FlatList
            data={cartItems}
            renderItem={renderCartItem}
            keyExtractor={item => item.id!.toString()}
            style={styles.cartList}
          />
          
          <View style={styles.totalContainer}>
            <Text style={styles.totalLabel}>Total:</Text>
            <Text style={styles.totalValue}>{formatCurrency(getTotal())}</Text>
          </View>

          <TouchableOpacity 
            style={[styles.submitButton, isSubmitting && styles.submitButtonDisabled]}
            onPress={handleSubmit}
            disabled={isSubmitting}
          >
            {isSubmitting ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator color="#FFF" size="small" />
                <Text style={[styles.submitButtonText, { marginLeft: 8 }]}>
                  Finalizando...
                </Text>
              </View>
            ) : (
              <Text style={styles.submitButtonText}>Finalizar Pedido</Text>
            )}
          </TouchableOpacity>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f6fa',
  },
  customerInfo: {
    flexDirection: 'row',
    padding: 16,
    alignItems: 'center',
  },
  input: {
    flex: 1,
    backgroundColor: '#FFF',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    borderWidth: 1,
    borderColor: '#DDD',
  },
  tableInput: {
    width: 80,
    marginLeft: 8,
    height: 45,
  },
  searchInput: {
    backgroundColor: '#FFF',
    margin: 16,
    marginTop: 0,
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    borderWidth: 1,
    borderColor: '#DDD',
  },
  content: {
    flex: 1,
    flexDirection: 'row',
  },
  productsContainer: {
    flex: 3,
    padding: 8,
  },
  productRow: {
    justifyContent: 'space-between',
    paddingHorizontal: 8,
  },
  productCard: {
    width: '48%',
    backgroundColor: '#FFF',
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  productName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  productCategory: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  productPrice: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#0a7ea4',
    marginTop: 8,
  },
  cartContainer: {
    flex: 2,
    backgroundColor: '#FFF',
    borderLeftWidth: 1,
    borderLeftColor: '#DDD',
    padding: 16,
  },
  cartTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 16,
  },
  cartList: {
    flex: 1,
  },
  cartItem: {
    borderBottomWidth: 1,
    borderBottomColor: '#EEE',
    paddingVertical: 12,
  },
  cartItemInfo: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  cartItemName: {
    fontSize: 16,
    color: '#333',
  },
  cartItemPrice: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#0a7ea4',
  },
  cartItemActions: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'flex-end',
    marginTop: 8,
    gap: 16,
  },
  cartItemQuantity: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    minWidth: 24,
    textAlign: 'center',
  },
  totalContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 16,
    borderTopWidth: 1,
    borderTopColor: '#DDD',
  },
  totalLabel: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  totalValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#0a7ea4',
  },
  submitButton: {
    backgroundColor: '#0a7ea4',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 16,
  },
  submitButtonDisabled: {
    opacity: 0.7,
  },
  submitButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  loadingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
});

================
File: app/screens/settings.tsx
================
import { TemporaryScreen } from '../components/TemporaryScreen';

export default function Settings() {
  return (
    <TemporaryScreen 
      title="Configurações" 
      icon="settings-outline" 
    />
  );
}

================
File: app/screens/users.tsx
================
import { useState, useCallback } from 'react';
import { View, Text, StyleSheet, FlatList, TouchableOpacity, ActivityIndicator } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { userRepository, User } from '../../database/userRepository';
import { useRouter, useFocusEffect } from 'expo-router';

export default function Users() {
  const [users, setUsers] = useState<User[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const router = useRouter();

  const loadUsers = useCallback(async () => {
    try {
      setIsLoading(true);
      const usersList = await userRepository.findAll();
      setUsers(usersList);
    } catch (error) {
      console.error('Erro ao carregar usuários:', error);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useFocusEffect(
    useCallback(() => {
      loadUsers();
    }, [loadUsers])
  );

  const handleDeactivateUser = async (userId: number) => {
    try {
      await userRepository.deactivate(userId);
      loadUsers();
    } catch (error) {
      console.error('Erro ao desativar usuário:', error);
    }
  };

  const handleEditUser = (userId: number) => {
    router.push({
      pathname: 'screens/users/edit',
      params: { userId }
    } as any);
  };

  const renderUserItem = ({ item }: { item: User }) => (
    <View style={styles.userCard}>
      <View style={styles.userInfo}>
        <Text style={styles.userName}>{item.name}</Text>
        <Text style={styles.userUsername}>@{item.username}</Text>
        <Text style={styles.userAccess}>
          Nível: {item.access_level_id === 1 ? 'Administrador' : 
                 item.access_level_id === 2 ? 'Gerente' : 
                 item.access_level_id === 3 ? 'Caixa' : 'Atendente'}
        </Text>
      </View>
      <View style={styles.userActions}>
        <TouchableOpacity 
          onPress={() => handleEditUser(item.id!)}
          style={styles.actionButton}
        >
          <Ionicons name="create-outline" size={24} color="#0a7ea4" />
        </TouchableOpacity>
        <TouchableOpacity 
          onPress={() => handleDeactivateUser(item.id!)}
          style={styles.actionButton}
        >
          <Ionicons name="trash-outline" size={24} color="#e74c3c" />
        </TouchableOpacity>
      </View>
    </View>
  );

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0a7ea4" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <TouchableOpacity 
        style={styles.addButton}
        onPress={() => router.push('screens/users/new' as any)}
      >
        <Ionicons name="add" size={24} color="#FFF" />
        <Text style={styles.addButtonText}>Novo Usuário</Text>
      </TouchableOpacity>

      {users.length === 0 ? (
        <View style={styles.emptyContainer}>
          <Text style={styles.emptyText}>Nenhum usuário cadastrado</Text>
        </View>
      ) : (
        <FlatList
          data={users}
          renderItem={renderUserItem}
          keyExtractor={item => item.id?.toString() || ''}
          contentContainerStyle={styles.listContainer}
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f6fa',
  },
  addButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#0a7ea4',
    padding: 16,
    margin: 16,
    borderRadius: 8,
  },
  addButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  listContainer: {
    padding: 16,
  },
  userCard: {
    flexDirection: 'row',
    backgroundColor: '#FFF',
    padding: 16,
    borderRadius: 8,
    marginBottom: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  userInfo: {
    flex: 1,
  },
  userName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  userUsername: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  userAccess: {
    fontSize: 14,
    color: '#0a7ea4',
    marginTop: 4,
  },
  userActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  actionButton: {
    padding: 8,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f6fa',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 20,
  },
  emptyText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
});

================
File: app/screens/users/edit.tsx
================
import { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TextInput, 
  TouchableOpacity,
  ScrollView,
  Alert,
  ActivityIndicator
} from 'react-native';
import { Picker } from '@react-native-picker/picker';
import { userRepository } from '../../../database/userRepository';
import { useRouter, useLocalSearchParams } from 'expo-router';

type AccessLevel = 1 | 2 | 3 | 4;

export default function EditUser() {
  const router = useRouter();
  const { userId } = useLocalSearchParams();
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [name, setName] = useState('');
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [phone, setPhone] = useState('');
  const [accessLevel, setAccessLevel] = useState<AccessLevel>(4);
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');

  useEffect(() => {
    loadUser();
  }, [userId]);

  const loadUser = async () => {
    try {
      setIsLoading(true);
      const user = await userRepository.findById(Number(userId));
      if (user) {
        setName(user.name);
        setUsername(user.username);
        setEmail(user.email || '');
        setPhone(user.phone || '');
        setAccessLevel(user.access_level_id as AccessLevel);
      }
    } catch (error) {
      console.error('Erro ao carregar usuário:', error);
      Alert.alert('Erro', 'Não foi possível carregar os dados do usuário');
    } finally {
      setIsLoading(false);
    }
  };

  const handleSubmit = async () => {
    if (isSubmitting) return;

    if (!name || !username) {
      Alert.alert('Erro', 'Por favor, preencha todos os campos obrigatórios');
      return;
    }

    if (password && password !== confirmPassword) {
      Alert.alert('Erro', 'As senhas não conferem');
      return;
    }

    try {
      setIsSubmitting(true);
      
      const updateData: any = {
        name,
        username,
        email,
        phone,
        access_level_id: accessLevel,
      };

      if (password) {
        updateData.password = password;
      }

      await userRepository.update(Number(userId), updateData);

      Alert.alert('Sucesso', 'Usuário atualizado com sucesso', [
        { 
          text: 'OK', 
          onPress: () => router.back() 
        }
      ]);
    } catch (error) {
      console.error('Erro ao atualizar usuário:', error);
      Alert.alert('Erro', 'Não foi possível atualizar o usuário');
    } finally {
      setIsSubmitting(false);
    }
  };

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0a7ea4" />
      </View>
    );
  }

  return (
    <ScrollView style={styles.container}>
      <View style={styles.form}>
        <Text style={styles.label}>Nome*</Text>
        <TextInput
          style={styles.input}
          value={name}
          onChangeText={setName}
          placeholder="Nome completo"
        />

        <Text style={styles.label}>Usuário*</Text>
        <TextInput
          style={styles.input}
          value={username}
          onChangeText={setUsername}
          placeholder="Nome de usuário"
          autoCapitalize="none"
        />

        <Text style={styles.label}>Nova Senha</Text>
        <TextInput
          style={styles.input}
          value={password}
          onChangeText={setPassword}
          placeholder="Digite apenas se quiser alterar"
          secureTextEntry
        />

        <Text style={styles.label}>Confirmar Nova Senha</Text>
        <TextInput
          style={styles.input}
          value={confirmPassword}
          onChangeText={setConfirmPassword}
          placeholder="Confirme a nova senha"
          secureTextEntry
        />

        <Text style={styles.label}>Email</Text>
        <TextInput
          style={styles.input}
          value={email}
          onChangeText={setEmail}
          placeholder="Email"
          keyboardType="email-address"
          autoCapitalize="none"
        />

        <Text style={styles.label}>Telefone</Text>
        <TextInput
          style={styles.input}
          value={phone}
          onChangeText={setPhone}
          placeholder="Telefone"
          keyboardType="phone-pad"
        />

        <Text style={styles.label}>Nível de Acesso*</Text>
        <View style={styles.pickerContainer}>
          <Picker
            selectedValue={accessLevel}
            onValueChange={(itemValue: AccessLevel) => setAccessLevel(itemValue)}
            style={styles.picker}
          >
            <Picker.Item label="Administrador" value={1} />
            <Picker.Item label="Gerente" value={2} />
            <Picker.Item label="Caixa" value={3} />
            <Picker.Item label="Atendente" value={4} />
          </Picker>
        </View>

        <TouchableOpacity 
          style={[styles.submitButton, isSubmitting && styles.submitButtonDisabled]}
          onPress={handleSubmit}
          disabled={isSubmitting}
        >
          {isSubmitting ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator color="#FFF" />
              <Text style={styles.loadingText}>Salvando...</Text>
            </View>
          ) : (
            <Text style={styles.submitButtonText}>Salvar Alterações</Text>
          )}
        </TouchableOpacity>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f6fa',
  },
  form: {
    padding: 16,
  },
  label: {
    fontSize: 16,
    color: '#333',
    marginBottom: 8,
    marginTop: 16,
  },
  input: {
    backgroundColor: '#FFF',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    borderWidth: 1,
    borderColor: '#DDD',
  },
  pickerContainer: {
    backgroundColor: '#FFF',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#DDD',
    overflow: 'hidden',
  },
  picker: {
    height: 50,
    width: '100%',
  },
  submitButton: {
    backgroundColor: "#0a7ea4",
    padding: 16,
    borderRadius: 8,
    alignItems: "center",
    marginTop: 24,
    height: 50,
  },
  submitButtonDisabled: {
    backgroundColor: "#999",
  },
  submitButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  loadingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    color: '#FFF',
    marginLeft: 8,
    fontSize: 16,
    fontWeight: 'bold',
  },
});

================
File: app/screens/users/new.tsx
================
import { useState } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TextInput, 
  TouchableOpacity,
  ScrollView,
  Alert,
  ActivityIndicator
} from 'react-native';
import { Picker } from '@react-native-picker/picker';
import { userRepository } from '../../../database/userRepository';
import { useRouter } from 'expo-router';

type AccessLevel = 1 | 2 | 3 | 4;

export default function NewUser() {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [name, setName] = useState('');
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [email, setEmail] = useState('');
  const [phone, setPhone] = useState('');
  const [accessLevel, setAccessLevel] = useState<AccessLevel>(4);

  const handleSubmit = async () => {
    if (isSubmitting) return;

    if (!name || !username || !password) {
      Alert.alert('Erro', 'Por favor, preencha todos os campos obrigatórios');
      return;
    }

    if (password !== confirmPassword) {
      Alert.alert('Erro', 'As senhas não conferem');
      return;
    }

    try {
      setIsSubmitting(true);
      
      await userRepository.create({
        name,
        username,
        password,
        email,
        phone,
        access_level_id: accessLevel,
        active: 1
      });

      Alert.alert('Sucesso', 'Usuário criado com sucesso', [
        { 
          text: 'OK', 
          onPress: () => router.back() 
        }
      ]);
    } catch (error) {
      console.error('Erro ao criar usuário:', error);
      Alert.alert('Erro', 'Não foi possível criar o usuário');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <ScrollView style={styles.container}>
      <View style={styles.form}>
        <Text style={styles.label}>Nome*</Text>
        <TextInput
          style={styles.input}
          value={name}
          onChangeText={setName}
          placeholder="Nome completo"
        />

        <Text style={styles.label}>Usuário*</Text>
        <TextInput
          style={styles.input}
          value={username}
          onChangeText={setUsername}
          placeholder="Nome de usuário"
          autoCapitalize="none"
        />

        <Text style={styles.label}>Senha*</Text>
        <TextInput
          style={styles.input}
          value={password}
          onChangeText={setPassword}
          placeholder="Senha"
          secureTextEntry
        />

        <Text style={styles.label}>Confirmar Senha*</Text>
        <TextInput
          style={styles.input}
          value={confirmPassword}
          onChangeText={setConfirmPassword}
          placeholder="Confirme a senha"
          secureTextEntry
        />

        <Text style={styles.label}>Email</Text>
        <TextInput
          style={styles.input}
          value={email}
          onChangeText={setEmail}
          placeholder="Email"
          keyboardType="email-address"
          autoCapitalize="none"
        />

        <Text style={styles.label}>Telefone</Text>
        <TextInput
          style={styles.input}
          value={phone}
          onChangeText={setPhone}
          placeholder="Telefone"
          keyboardType="phone-pad"
        />

        <Text style={styles.label}>Nível de Acesso*</Text>
        <View style={styles.pickerContainer}>
          <Picker
            selectedValue={accessLevel}
            onValueChange={(itemValue: AccessLevel) => setAccessLevel(itemValue)}
            style={styles.picker}
          >
            <Picker.Item label="Administrador" value={1} />
            <Picker.Item label="Gerente" value={2} />
            <Picker.Item label="Caixa" value={3} />
            <Picker.Item label="Atendente" value={4} />
          </Picker>
        </View>

        <TouchableOpacity 
          style={[styles.submitButton, isSubmitting && styles.submitButtonDisabled]}
          onPress={handleSubmit}
          disabled={isSubmitting}
        >
          {isSubmitting ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator color="#FFF" />
              <Text style={styles.loadingText}>Salvando...</Text>
            </View>
          ) : (
            <Text style={styles.submitButtonText}>Criar Usuário</Text>
          )}
        </TouchableOpacity>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f6fa',
  },
  form: {
    padding: 16,
  },
  label: {
    fontSize: 16,
    color: '#333',
    marginBottom: 8,
    marginTop: 16,
  },
  input: {
    backgroundColor: '#FFF',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    borderWidth: 1,
    borderColor: '#DDD',
  },
  pickerContainer: {
    backgroundColor: '#FFF',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#DDD',
    overflow: 'hidden',
  },
  picker: {
    height: 50,
    width: '100%',
  },
  submitButton: {
    backgroundColor: "#0a7ea4",
    padding: 16,
    borderRadius: 8,
    alignItems: "center",
    marginTop: 24,
    height: 50,
  },
  submitButtonDisabled: {
    backgroundColor: "#999",
  },
  submitButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  loadingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    color: '#FFF',
    marginLeft: 8,
    fontSize: 16,
    fontWeight: 'bold',
  },
});

================
File: babel.config.js
================
module.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
  };
};

================
File: components/__tests__/__snapshots__/ThemedText-test.tsx.snap
================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders correctly 1`] = `
<Text
  style={
    [
      {
        "color": "#11181C",
      },
      {
        "fontSize": 16,
        "lineHeight": 24,
      },
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
    ]
  }
>
  Snapshot test!
</Text>
`;

================
File: components/__tests__/ThemedText-test.tsx
================
import * as React from 'react';
import renderer from 'react-test-renderer';

import { ThemedText } from '../ThemedText';

it(`renders correctly`, () => {
  const tree = renderer.create(<ThemedText>Snapshot test!</ThemedText>).toJSON();

  expect(tree).toMatchSnapshot();
});

================
File: components/Collapsible.tsx
================
import Ionicons from '@expo/vector-icons/Ionicons';
import { PropsWithChildren, useState } from 'react';
import { StyleSheet, TouchableOpacity, useColorScheme } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { Colors } from '@/constants/Colors';

export function Collapsible({ children, title }: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? 'light';

  return (
    <ThemedView>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}>
        <Ionicons
          name={isOpen ? 'chevron-down' : 'chevron-forward-outline'}
          size={18}
          color={theme === 'light' ? Colors.light.icon : Colors.dark.icon}
        />
        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <ThemedView style={styles.content}>{children}</ThemedView>}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});

================
File: components/ExternalLink.tsx
================
import { Link } from 'expo-router';
import { openBrowserAsync } from 'expo-web-browser';
import { type ComponentProps } from 'react';
import { Platform } from 'react-native';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (Platform.OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href);
        }
      }}
    />
  );
}

================
File: components/HelloWave.tsx
================
import { StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withRepeat,
  withSequence,
} from 'react-native-reanimated';

import { ThemedText } from '@/components/ThemedText';

export function HelloWave() {
  const rotationAnimation = useSharedValue(0);

  rotationAnimation.value = withRepeat(
    withSequence(withTiming(25, { duration: 150 }), withTiming(0, { duration: 150 })),
    4 // Run the animation 4 times
  );

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotationAnimation.value}deg` }],
  }));

  return (
    <Animated.View style={animatedStyle}>
      <ThemedText style={styles.text}>👋</ThemedText>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  text: {
    fontSize: 28,
    lineHeight: 32,
    marginTop: -6,
  },
});

================
File: components/navigation/TabBarIcon.tsx
================
// You can explore the built-in icon families and icons on the web at https://icons.expo.fyi/

import Ionicons from '@expo/vector-icons/Ionicons';
import { type IconProps } from '@expo/vector-icons/build/createIconSet';
import { type ComponentProps } from 'react';

export function TabBarIcon({ style, ...rest }: IconProps<ComponentProps<typeof Ionicons>['name']>) {
  return <Ionicons size={28} style={[{ marginBottom: -3 }, style]} {...rest} />;
}

================
File: components/ParallaxScrollView.tsx
================
import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet, useColorScheme } from 'react-native';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollViewOffset,
} from 'react-native-reanimated';

import { ThemedView } from '@/components/ThemedView';

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}>;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const colorScheme = useColorScheme() ?? 'light';
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollViewOffset(scrollRef);

  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    <ThemedView style={styles.container}>
      <Animated.ScrollView ref={scrollRef} scrollEventThrottle={16}>
        <Animated.View
          style={[
            styles.header,
            { backgroundColor: headerBackgroundColor[colorScheme] },
            headerAnimatedStyle,
          ]}>
          {headerImage}
        </Animated.View>
        <ThemedView style={styles.content}>{children}</ThemedView>
      </Animated.ScrollView>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: 250,
    overflow: 'hidden',
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: 'hidden',
  },
});

================
File: components/ThemedText.tsx
================
import { Text, type TextProps, StyleSheet } from 'react-native';

import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: '#0a7ea4',
  },
});

================
File: components/ThemedView.tsx
================
import { View, type ViewProps } from 'react-native';

import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}

================
File: constants/Colors.ts
================
/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

const tintColorLight = '#0a7ea4';
const tintColorDark = '#fff';

export const Colors = {
  light: {
    text: '#11181C',
    background: '#fff',
    tint: tintColorLight,
    icon: '#687076',
    tabIconDefault: '#687076',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#ECEDEE',
    background: '#151718',
    tint: tintColorDark,
    icon: '#9BA1A6',
    tabIconDefault: '#9BA1A6',
    tabIconSelected: tintColorDark,
  },
};

================
File: contexts/AuthContext.tsx
================
import { createContext, useContext, useState, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { User } from '../database/userRepository';

interface AuthContextData {
  user: User | null;
  signIn: (user: User) => Promise<void>;
  signOut: () => Promise<void>;
  isLoading: boolean;
}

const AuthContext = createContext<AuthContextData>({} as AuthContextData);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    loadStoredData();
  }, []);

  async function loadStoredData() {
    try {
      const storedUser = await AsyncStorage.getItem('@LanchoneteApp:user');
      if (storedUser) {
        setUser(JSON.parse(storedUser));
      }
    } catch (error) {
      console.error('Erro ao carregar dados do usuário:', error);
    } finally {
      setIsLoading(false);
    }
  }

  async function signIn(userData: User) {
    try {
      await AsyncStorage.setItem('@LanchoneteApp:user', JSON.stringify(userData));
      setUser(userData);
    } catch (error) {
      console.error('Erro ao salvar dados do usuário:', error);
      throw error;
    }
  }

  async function signOut() {
    try {
      await AsyncStorage.removeItem('@LanchoneteApp:user');
      setUser(null);
    } catch (error) {
      console.error('Erro ao remover dados do usuário:', error);
      throw error;
    }
  }

  return (
    <AuthContext.Provider value={{ user, signIn, signOut, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

================
File: database/cashRepository.ts
================
import { getDatabase } from "./database";

export interface CashMovement {
  id?: number;
  type: "opening" | "closing" | "sale" | "expense" | "withdrawal" | "deposit";
  amount: number;
  description?: string;
  order_id?: number;
  created_at?: string;
  user_id: number;
  user_name?: string;
  table_number?: string;
}

export interface CashStatus {
  id?: number;
  is_open: boolean;
  opened_at?: string;
  opened_by?: number;
  initial_amount: number;
  current_amount: number;
}

export const cashRepository = {
  async openCashier(userId: number, initialAmount: number): Promise<void> {
    const db = getDatabase();
    return new Promise((resolve, reject) => {
      db.transaction((tx) => {
        // Verificar se o caixa já está aberto
        tx.executeSql(
          "SELECT * FROM cash_status WHERE is_open = 1",
          [],
          (_, { rows }) => {
            if (rows.length > 0) {
              reject(new Error("O caixa já está aberto"));
              return;
            }

            // Abrir o caixa
            tx.executeSql(
              `INSERT INTO cash_status (is_open, opened_at, opened_by, initial_amount, current_amount)
               VALUES (1, CURRENT_TIMESTAMP, ?, ?, ?)`,
              [userId, initialAmount, initialAmount],
              (_, result) => {
                // Registrar movimento de abertura
                tx.executeSql(
                  `INSERT INTO cash_movements (type, amount, description, user_id)
                   VALUES ('opening', ?, 'Abertura de caixa', ?)`,
                  [initialAmount, userId],
                  () => resolve(),
                  (_, error) => {
                    reject(error);
                    return false;
                  }
                );
              },
              (_, error) => {
                reject(error);
                return false;
              }
            );
          }
        );
      });
    });
  },

  async closeCashier(userId: number): Promise<void> {
    const db = getDatabase();
    return new Promise((resolve, reject) => {
      db.transaction((tx) => {
        // Verificar se o caixa está aberto
        tx.executeSql(
          "SELECT * FROM cash_status WHERE is_open = 1",
          [],
          (_, { rows }) => {
            if (rows.length === 0) {
              reject(new Error("O caixa não está aberto"));
              return;
            }

            const currentStatus = rows.item(0);

            // Registrar movimento de fechamento
            tx.executeSql(
              `INSERT INTO cash_movements (type, amount, description, user_id)
               VALUES ('closing', ?, 'Fechamento de caixa', ?)`,
              [currentStatus.current_amount, userId],
              () => {
                // Fechar o caixa
                tx.executeSql(
                  "UPDATE cash_status SET is_open = 0 WHERE is_open = 1",
                  [],
                  () => resolve(),
                  (_, error) => {
                    reject(error);
                    return false;
                  }
                );
              },
              (_, error) => {
                reject(error);
                return false;
              }
            );
          }
        );
      });
    });
  },

  async getCurrentStatus(): Promise<CashStatus | null> {
    const db = getDatabase();
    return new Promise((resolve, reject) => {
      db.transaction((tx) => {
        tx.executeSql(
          `SELECT cs.*, u.name as opened_by_name 
           FROM cash_status cs
           LEFT JOIN users u ON cs.opened_by = u.id
           WHERE cs.is_open = 1`,
          [],
          (_, { rows }) => {
            if (rows.length > 0) {
              resolve(rows.item(0));
            } else {
              resolve(null);
            }
          },
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  },

  async addMovement(movement: CashMovement): Promise<void> {
    const db = getDatabase();
    return new Promise((resolve, reject) => {
      db.transaction((tx) => {
        tx.executeSql(
          `INSERT INTO cash_movements (type, amount, description, order_id, user_id)
           VALUES (?, ?, ?, ?, ?)`,
          [
            movement.type,
            movement.amount,
            movement.description || null,
            movement.order_id || null,
            movement.user_id,
          ],
          () => {
            // Atualizar saldo atual
            const amountChange = ["withdrawal", "expense"].includes(
              movement.type
            )
              ? -movement.amount
              : movement.amount;

            tx.executeSql(
              "UPDATE cash_status SET current_amount = current_amount + ? WHERE is_open = 1",
              [amountChange],
              () => resolve(),
              (_, error) => {
                reject(error);
                return false;
              }
            );
          },
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  },

  async getMovements(date?: string): Promise<CashMovement[]> {
    const db = getDatabase();
    return new Promise((resolve, reject) => {
      db.transaction((tx) => {
        const dateFilter = date ? "AND date(cm.created_at) = date(?)" : "";

        tx.executeSql(
          `SELECT cm.*, u.name as user_name, o.table_number
           FROM cash_movements cm
           LEFT JOIN users u ON cm.user_id = u.id
           LEFT JOIN orders o ON cm.order_id = o.id
           WHERE 1=1 ${dateFilter}
           ORDER BY cm.created_at DESC`,
          date ? [date] : [],
          (_, { rows }) => {
            resolve(rows._array);
          },
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  },
};

================
File: database/customerRepository.ts
================
import { getDatabase } from "./database";

export interface Customer {
  id?: number;
  name: string;
  phone?: string;
  email?: string;
  address?: string;
  notes?: string;
  created_at?: string;
}

export const customerRepository = {
  async create(customer: Customer): Promise<void> {
    return new Promise((resolve, reject) => {
      const db = getDatabase();
      db.transaction((tx) => {
        tx.executeSql(
          `INSERT INTO customers (name, phone, email, address, notes) 
           VALUES (?, ?, ?, ?, ?)`,
          [
            customer.name,
            customer.phone || null,
            customer.email || null,
            customer.address || null,
            customer.notes || null,
          ],
          (_, result) => resolve(),
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  },

  async findAll(): Promise<Customer[]> {
    return new Promise((resolve, reject) => {
      const db = getDatabase();
      db.transaction((tx) => {
        tx.executeSql(
          "SELECT * FROM customers ORDER BY name",
          [],
          (_, { rows }) => resolve(rows._array),
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  },

  async findById(id: number): Promise<Customer | null> {
    return new Promise((resolve, reject) => {
      const db = getDatabase();
      db.transaction((tx) => {
        tx.executeSql(
          "SELECT * FROM customers WHERE id = ?",
          [id],
          (_, { rows }) => {
            if (rows.length > 0) {
              resolve(rows.item(0));
            } else {
              resolve(null);
            }
          },
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  },

  async update(id: number, customer: Partial<Customer>): Promise<void> {
    return new Promise((resolve, reject) => {
      const db = getDatabase();
      db.transaction((tx) => {
        tx.executeSql(
          `UPDATE customers 
           SET name = ?, phone = ?, email = ?, address = ?, notes = ?
           WHERE id = ?`,
          [
            customer.name ?? "",
            customer.phone ?? null,
            customer.email ?? null,
            customer.address ?? null,
            customer.notes ?? null,
            id,
          ],
          (_, result) => resolve(),
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  },

  async delete(id: number): Promise<void> {
    return new Promise((resolve, reject) => {
      const db = getDatabase();
      db.transaction((tx) => {
        tx.executeSql(
          "DELETE FROM customers WHERE id = ?",
          [id],
          (_, result) => resolve(),
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  },

  async findByName(search: string): Promise<Customer[]> {
    return new Promise((resolve, reject) => {
      const db = getDatabase();
      db.transaction((tx) => {
        tx.executeSql(
          `SELECT * FROM customers 
           WHERE name LIKE ? 
           ORDER BY name 
           LIMIT 5`,
          [`%${search}%`],
          (_, { rows }) => resolve(rows._array),
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  },
};

================
File: database/database.ts
================
import {
  openDatabase,
  SQLTransaction,
  SQLResultSet,
  SQLError,
} from "expo-sqlite/legacy";
import * as FileSystem from "expo-file-system";

const DB_NAME = "lanchonete.db";
let db: ReturnType<typeof openDatabase>;

const getDatabasePath = async () => {
  const documentDirectory = FileSystem.documentDirectory;
  return documentDirectory ? `${documentDirectory}SQLite/${DB_NAME}` : DB_NAME;
};

const ensureDatabaseDirectoryExists = async () => {
  const dbDirectory = `${FileSystem.documentDirectory}SQLite`;
  const { exists } = await FileSystem.getInfoAsync(dbDirectory);
  if (!exists) {
    await FileSystem.makeDirectoryAsync(dbDirectory, { intermediates: true });
  }
};

export const initDatabase = async () => {
  console.log("Iniciando banco de dados...");
  try {
    await ensureDatabaseDirectoryExists();
    const dbPath = await getDatabasePath();

    db = openDatabase(DB_NAME);

    // Criar tabela de produtos
    await new Promise<void>((resolve, reject) => {
      db.transaction((tx) => {
        tx.executeSql(
          `
          CREATE TABLE IF NOT EXISTS products (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            description TEXT,
            price REAL NOT NULL,
            category TEXT NOT NULL,
            image TEXT,
            active INTEGER DEFAULT 1,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP,
            updated_at TEXT DEFAULT CURRENT_TIMESTAMP
          )
        `,
          [],
          () => resolve(),
          (_, error) => {
            reject(error);
            return true; // Indica que o erro foi tratado
          }
        );
      });
    });

    // Criar tabelas de pedidos
    await new Promise<void>((resolve, reject) => {
      db.transaction(
        (tx) => {
          // Tabela de pedidos
          tx.executeSql(`
          CREATE TABLE IF NOT EXISTS orders (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            customer_name TEXT,
            table_number INTEGER,
            status TEXT NOT NULL,
            total REAL NOT NULL,
            payment_method TEXT,
            notes TEXT,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP,
            updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
            user_id INTEGER,
            FOREIGN KEY (user_id) REFERENCES users (id)
          )
        `);

          // Tabela de itens do pedido
          tx.executeSql(`
          CREATE TABLE IF NOT EXISTS order_items (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            order_id INTEGER NOT NULL,
            product_id INTEGER NOT NULL,
            quantity INTEGER NOT NULL,
            unit_price REAL NOT NULL,
            notes TEXT,
            FOREIGN KEY (order_id) REFERENCES orders (id),
            FOREIGN KEY (product_id) REFERENCES products (id)
          )
        `);

          resolve();
        },
        (error) => {
          reject(error);
          return true;
        }
      );
    });

    return new Promise((resolve, reject) => {
      db.transaction(
        (tx) => {
          // Tabela de níveis de acesso
          tx.executeSql(
            `CREATE TABLE IF NOT EXISTS access_levels (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              name TEXT NOT NULL,
              description TEXT
            );`
          );

          // Tabela de usuários
          tx.executeSql(
            `CREATE TABLE IF NOT EXISTS users (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              username TEXT NOT NULL UNIQUE,
              password TEXT NOT NULL,
              name TEXT NOT NULL,
              email TEXT,
              phone TEXT,
              access_level_id INTEGER,
              active INTEGER DEFAULT 1,
              created_at TEXT DEFAULT CURRENT_TIMESTAMP,
              last_login TEXT,
              FOREIGN KEY (access_level_id) REFERENCES access_levels (id)
            );`
          );

          // Verificar se já existem níveis de acesso
          tx.executeSql(
            "SELECT COUNT(*) as count FROM access_levels",
            [],
            (_, { rows }) => {
              if (rows.item(0).count === 0) {
                // Inserir níveis de acesso padrão apenas se não existirem
                tx.executeSql(
                  `INSERT INTO access_levels (id, name, description) VALUES 
                  (1, 'admin', 'Acesso total ao sistema'),
                  (2, 'gerente', 'Acesso a relatórios e gestão'),
                  (3, 'caixa', 'Acesso a vendas e consultas'),
                  (4, 'atendente', 'Acesso básico ao sistema');`
                );
              }
            }
          );

          // Verificar se já existe usuário admin
          tx.executeSql(
            "SELECT COUNT(*) as count FROM users WHERE username = ?",
            ["admin"],
            (_, { rows }) => {
              if (rows.item(0).count === 0) {
                // Inserir usuário admin padrão apenas se não existir
                tx.executeSql(
                  `INSERT INTO users (username, password, name, access_level_id) 
                  VALUES ('admin', 'admin123', 'Administrador', 1);`
                );
              }
            }
          );

          // Tabela de clientes
          tx.executeSql(
            `CREATE TABLE IF NOT EXISTS customers (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              name TEXT NOT NULL,
              phone TEXT,
              email TEXT,
              address TEXT,
              notes TEXT,
              created_at TEXT DEFAULT CURRENT_TIMESTAMP
            );`
          );

          // Verificar se a coluna customer_id existe na tabela orders
          tx.executeSql(
            `SELECT name FROM pragma_table_info('orders') WHERE name = 'customer_id'`,
            [],
            (_, { rows }) => {
              if (rows.length === 0) {
                // Adicionar coluna customer_id se não existir
                tx.executeSql(
                  `ALTER TABLE orders ADD COLUMN customer_id INTEGER NULL 
                   REFERENCES customers(id)`,
                  [],
                  () => {
                    console.log("Coluna customer_id adicionada com sucesso");
                  },
                  (_, error) => {
                    // Ignora erro se a coluna já existir
                    if (!error.message.includes("duplicate column name")) {
                      console.error(
                        "Erro ao adicionar coluna customer_id:",
                        error
                      );
                      return false;
                    }
                    return true;
                  }
                );
              }
            }
          );

          // Tabela de movimentações do caixa
          tx.executeSql(
            `CREATE TABLE IF NOT EXISTS cash_movements (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              type TEXT NOT NULL, -- 'opening', 'closing', 'sale', 'expense', 'withdrawal', 'deposit'
              amount REAL NOT NULL,
              description TEXT,
              order_id INTEGER NULL,
              created_at TEXT DEFAULT CURRENT_TIMESTAMP,
              user_id INTEGER NOT NULL,
              FOREIGN KEY (order_id) REFERENCES orders(id),
              FOREIGN KEY (user_id) REFERENCES users(id)
            );`
          );

          // Tabela de status do caixa
          tx.executeSql(
            `CREATE TABLE IF NOT EXISTS cash_status (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              is_open BOOLEAN NOT NULL DEFAULT 0,
              opened_at TEXT,
              opened_by INTEGER,
              initial_amount REAL,
              current_amount REAL,
              FOREIGN KEY (opened_by) REFERENCES users(id)
            );`
          );

          // Verificar se a coluna user_id existe na tabela orders
          tx.executeSql(
            `SELECT name FROM pragma_table_info('orders') WHERE name = 'user_id'`,
            [],
            (_, { rows }) => {
              if (rows.length === 0) {
                // Adicionar coluna user_id se não existir
                tx.executeSql(
                  `ALTER TABLE orders ADD COLUMN user_id INTEGER NOT NULL DEFAULT 1 
                   REFERENCES users(id)`,
                  [],
                  () => {
                    console.log("Coluna user_id adicionada com sucesso");
                  },
                  (_, error) => {
                    console.error("Erro ao adicionar coluna user_id:", error);
                    return false;
                  }
                );
              }
            }
          );

          // Verificar se precisamos renomear a coluna price para unit_price na tabela order_items
          tx.executeSql(
            `SELECT name FROM pragma_table_info('order_items') WHERE name = 'price'`,
            [],
            (_, { rows }) => {
              if (rows.length > 0) {
                // Renomear coluna price para unit_price
                tx.executeSql(
                  `ALTER TABLE order_items RENAME COLUMN price TO unit_price`,
                  [],
                  () => {
                    console.log(
                      "Coluna price renomeada para unit_price com sucesso"
                    );
                  },
                  (_, error) => {
                    console.error("Erro ao renomear coluna price:", error);
                    return false;
                  }
                );
              }
            }
          );

          // Adicionar à função initDatabase
          tx.executeSql(
            `CREATE TABLE IF NOT EXISTS inventory_movements (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              product_id INTEGER NOT NULL,
              type TEXT NOT NULL, -- 'in' ou 'out'
              quantity INTEGER NOT NULL,
              reason TEXT NOT NULL, -- 'sale', 'purchase', 'adjustment'
              order_id INTEGER,
              notes TEXT,
              created_at TEXT DEFAULT CURRENT_TIMESTAMP,
              user_id INTEGER NOT NULL,
              FOREIGN KEY (product_id) REFERENCES products(id),
              FOREIGN KEY (order_id) REFERENCES orders(id),
              FOREIGN KEY (user_id) REFERENCES users(id)
            );`
          );

          tx.executeSql(
            `CREATE TABLE IF NOT EXISTS product_stock (
              product_id INTEGER PRIMARY KEY,
              quantity INTEGER NOT NULL DEFAULT 0,
              min_quantity INTEGER DEFAULT 0,
              last_updated TEXT DEFAULT CURRENT_TIMESTAMP,
              FOREIGN KEY (product_id) REFERENCES products(id)
            );`
          );
        },
        (error) => {
          console.error("Erro ao inicializar banco de dados:", error);
          reject(error);
        },
        () => {
          console.log("Banco de dados inicializado com sucesso");
          resolve(true);
        }
      );
    });
  } catch (error) {
    console.error("Erro ao configurar banco de dados:", error);
    throw error;
  }
};

export const getDatabase = () => {
  console.log("Obtendo instância do banco de dados...");
  return db;
};

================
File: database/orderRepository.ts
================
import { getDatabase } from "./database";
import { Product } from "./productRepository";
import { cashRepository } from "./cashRepository";

export interface OrderItem {
  id?: number;
  order_id?: number;
  product_id: number;
  quantity: number;
  unit_price: number;
  notes?: string;
  product?: {
    id: number;
    name: string;
    price: number;
    category: string;
  };
}

export interface Order {
  id?: number;
  customer_id?: number | null;
  user_id: number;
  table_number?: string;
  status: string;
  total: number;
  created_at?: string;
  items: OrderItem[];
  _customer?: {
    name: string;
    phone?: string;
  };
}

export const orderRepository = {
  async create(order: Order): Promise<number> {
    const db = getDatabase();
    console.log("Iniciando criação do pedido");

    // Verificar se o caixa está aberto antes da transação
    const cashStatus = await cashRepository.getCurrentStatus();
    if (!cashStatus?.is_open) {
      throw new Error("O caixa precisa estar aberto para registrar vendas");
    }

    return new Promise((resolve, reject) => {
      db.transaction(
        (tx) => {
          // Primeiro, inserir o pedido
          tx.executeSql(
            `INSERT INTO orders (customer_id, user_id, table_number, status, total) 
           VALUES (?, ?, ?, ?, ?)`,
            [
              order.customer_id || null,
              order.user_id,
              order.table_number || null,
              order.status,
              order.total,
            ],
            (_, result) => {
              const orderId = result.insertId!;
              console.log("Pedido inserido, ID:", orderId);

              // Depois, inserir os itens
              order.items.forEach((item) => {
                tx.executeSql(
                  `INSERT INTO order_items (order_id, product_id, quantity, unit_price) 
                 VALUES (?, ?, ?, ?)`,
                  [orderId, item.product_id, item.quantity, item.unit_price],
                  () => {
                    console.log("Item inserido para o pedido:", orderId);
                  },
                  (_, error) => {
                    console.error("Erro ao inserir item:", error);
                    return false;
                  }
                );
              });

              // Por fim, registrar no caixa
              tx.executeSql(
                `INSERT INTO cash_movements (type, amount, description, order_id, user_id)
               VALUES (?, ?, ?, ?, ?)`,
                [
                  "sale",
                  order.total,
                  `Venda - Pedido #${orderId}${
                    order.table_number ? ` - Mesa ${order.table_number}` : ""
                  }`,
                  orderId,
                  order.user_id,
                ],
                () => {
                  console.log("Movimento de caixa registrado");
                  // Atualizar o saldo do caixa
                  tx.executeSql(
                    "UPDATE cash_status SET current_amount = current_amount + ? WHERE is_open = 1",
                    [order.total],
                    () => {
                      console.log("Saldo do caixa atualizado");
                      resolve(orderId);
                    },
                    (_, error) => {
                      console.error("Erro ao atualizar saldo:", error);
                      return false;
                    }
                  );
                },
                (_, error) => {
                  console.error("Erro ao registrar movimento:", error);
                  return false;
                }
              );
            },
            (_, error) => {
              console.error("Erro ao inserir pedido:", error);
              reject(error);
              return false;
            }
          );
        },
        (error) => {
          console.error("Erro na transação:", error);
          reject(error);
        },
        () => {
          console.log("Transação completada com sucesso");
        }
      );
    });
  },

  async findById(id: number): Promise<Order | null> {
    const db = getDatabase();
    return new Promise((resolve, reject) => {
      db.transaction((tx) => {
        tx.executeSql(
          `SELECT o.*, c.name as customer_name, c.phone as customer_phone
           FROM orders o
           LEFT JOIN customers c ON o.customer_id = c.id
           WHERE o.id = ?`,
          [id],
          async (_, { rows }) => {
            if (rows.length === 0) {
              resolve(null);
              return;
            }

            const orderData = rows.item(0);

            // Buscar os itens do pedido
            tx.executeSql(
              `SELECT oi.*, p.name as product_name 
               FROM order_items oi
               JOIN products p ON oi.product_id = p.id
               WHERE oi.order_id = ?`,
              [id],
              (_, { rows: itemRows }) => {
                const items = [];
                for (let i = 0; i < itemRows.length; i++) {
                  items.push(itemRows.item(i));
                }

                // Construir o objeto Order com a estrutura correta
                const order: Order = {
                  id: orderData.id,
                  customer_id: orderData.customer_id,
                  user_id: orderData.user_id,
                  table_number: orderData.table_number,
                  status: orderData.status,
                  total: orderData.total,
                  created_at: orderData.created_at,
                  items,
                  _customer: orderData.customer_name
                    ? {
                        name: orderData.customer_name,
                        phone: orderData.customer_phone,
                      }
                    : undefined,
                };

                resolve(order);
              }
            );
          },
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  },

  async findAll(): Promise<Order[]> {
    return new Promise((resolve, reject) => {
      const db = getDatabase();

      db.transaction((tx) => {
        tx.executeSql(
          `SELECT o.*, c.name as customer_name, c.phone as customer_phone
           FROM orders o
           LEFT JOIN customers c ON o.customer_id = c.id
           ORDER BY o.created_at DESC`,
          [],
          (_, { rows }) => {
            const orders = rows._array.map((row) => ({
              id: row.id,
              customer_id: row.customer_id,
              user_id: row.user_id,
              table_number: row.table_number,
              status: row.status,
              total: row.total,
              created_at: row.created_at,
              items: [], // Será preenchido depois se necessário
              _customer: row.customer_name
                ? {
                    name: row.customer_name,
                    phone: row.customer_phone,
                  }
                : undefined,
            }));

            resolve(orders);
          },
          (_, error) => {
            reject(error);
            return true;
          }
        );
      });
    });
  },

  async updateStatus(id: number, status: Order["status"]): Promise<void> {
    return new Promise((resolve, reject) => {
      const db = getDatabase();

      db.transaction((tx) => {
        tx.executeSql(
          `UPDATE orders SET status = ?, updated_at = CURRENT_TIMESTAMP 
           WHERE id = ?`,
          [status, id],
          () => resolve(),
          (_, error) => {
            reject(error);
            return true;
          }
        );
      });
    });
  },
};

================
File: database/productRepository.ts
================
import { getDatabase } from './database';

export interface Product {
  id?: number;
  name: string;
  description?: string;
  price: number;
  category: string;
  image?: string;
  active?: number;
  created_at?: string;
  updated_at?: string;
}

class ProductRepository {
  async create(product: Product): Promise<void> {
    return new Promise((resolve, reject) => {
      const db = getDatabase();
      
      db.transaction(tx => {
        tx.executeSql(
          `INSERT INTO products (name, description, price, category, image) 
           VALUES (?, ?, ?, ?, ?)`,
          [
            product.name,
            product.description || null,
            product.price,
            product.category,
            product.image || null
          ],
          (_, result) => resolve(),
          (_, error) => {
            reject(error);
            return true;
          }
        );
      });
    });
  }

  async update(id: number, product: Partial<Product>): Promise<void> {
    return new Promise((resolve, reject) => {
      const db = getDatabase();
      const updates: string[] = [];
      const values: any[] = [];

      Object.entries(product).forEach(([key, value]) => {
        if (value !== undefined && key !== 'id') {
          updates.push(`${key} = ?`);
          values.push(value);
        }
      });

      values.push(id);

      db.transaction(tx => {
        tx.executeSql(
          `UPDATE products SET ${updates.join(', ')}, updated_at = CURRENT_TIMESTAMP 
           WHERE id = ?`,
          values,
          (_, result) => resolve(),
          (_, error) => {
            reject(error);
            return true;
          }
        );
      });
    });
  }

  async findAll(): Promise<Product[]> {
    return new Promise((resolve, reject) => {
      const db = getDatabase();
      
      db.transaction(tx => {
        tx.executeSql(
          'SELECT * FROM products WHERE active = 1 ORDER BY name',
          [],
          (_, { rows: { _array } }) => resolve(_array),
          (_, error) => {
            reject(error);
            return true;
          }
        );
      });
    });
  }

  async findById(id: number): Promise<Product | null> {
    return new Promise((resolve, reject) => {
      const db = getDatabase();
      
      db.transaction(tx => {
        tx.executeSql(
          'SELECT * FROM products WHERE id = ? AND active = 1',
          [id],
          (_, { rows: { _array } }) => resolve(_array[0] || null),
          (_, error) => {
            reject(error);
            return true;
          }
        );
      });
    });
  }

  async deactivate(id: number): Promise<void> {
    return new Promise((resolve, reject) => {
      const db = getDatabase();
      
      db.transaction(tx => {
        tx.executeSql(
          'UPDATE products SET active = 0, updated_at = CURRENT_TIMESTAMP WHERE id = ?',
          [id],
          (_, result) => resolve(),
          (_, error) => {
            reject(error);
            return true;
          }
        );
      });
    });
  }
}

export const productRepository = new ProductRepository();

================
File: database/userRepository.ts
================
import { getDatabase } from './database';

export interface User {
  id?: number;
  username: string;
  password: string;
  name: string;
  email?: string;
  phone?: string;
  access_level_id: number;
  active?: number;
  created_at?: string;
  last_login?: string;
}

export const userRepository = {
  create: (user: User): Promise<number> => {
    return new Promise((resolve, reject) => {
      getDatabase().transaction((tx) => {
        tx.executeSql(
          `INSERT INTO users (username, password, name, email, phone, access_level_id) 
           VALUES (?, ?, ?, ?, ?, ?)`,
          [
            user.username, 
            user.password, 
            user.name, 
            user.email || null, 
            user.phone || null, 
            user.access_level_id
          ],
          (_, result) => resolve(result.insertId || 0),
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  },

  authenticate: (username: string, password: string): Promise<User | null> => {
    return new Promise((resolve, reject) => {
      getDatabase().transaction((tx) => {
        tx.executeSql(
          `SELECT u.*, al.name as access_level_name 
           FROM users u 
           JOIN access_levels al ON u.access_level_id = al.id 
           WHERE u.username = ? AND u.password = ? AND u.active = 1`,
          [username, password],
          (_, { rows }) => {
            if (rows.length > 0) {
              tx.executeSql(
                'UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = ?',
                [rows.item(0).id]
              );
              resolve(rows.item(0));
            } else {
              resolve(null);
            }
          },
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  },

  findAll: (): Promise<User[]> => {
    return new Promise((resolve, reject) => {
      getDatabase().transaction((tx) => {
        tx.executeSql(
          `SELECT u.*, al.name as access_level_name 
           FROM users u 
           JOIN access_levels al ON u.access_level_id = al.id`,
          [],
          (_, { rows }) => resolve(rows._array),
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  },

  update: (id: number, user: Partial<User>): Promise<void> => {
    const fields = Object.keys(user).map(key => `${key} = ?`).join(', ');
    const values = [...Object.values(user).map(v => v ?? null), id];

    return new Promise((resolve, reject) => {
      getDatabase().transaction((tx) => {
        tx.executeSql(
          `UPDATE users SET ${fields} WHERE id = ?`,
          values,
          () => resolve(),
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  },

  deactivate: (id: number): Promise<void> => {
    return new Promise((resolve, reject) => {
      getDatabase().transaction((tx) => {
        tx.executeSql(
          'UPDATE users SET active = 0 WHERE id = ?',
          [id],
          () => resolve(),
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  },

  findById: (id: number): Promise<User | null> => {
    return new Promise((resolve, reject) => {
      getDatabase().transaction((tx) => {
        tx.executeSql(
          `SELECT u.*, al.name as access_level_name 
           FROM users u 
           JOIN access_levels al ON u.access_level_id = al.id 
           WHERE u.id = ?`,
          [id],
          (_, { rows }) => {
            if (rows.length > 0) {
              resolve(rows.item(0));
            } else {
              resolve(null);
            }
          },
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  }
};

================
File: eas.json
================
{
  "cli": {
    "version": ">= 12.6.2",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "distribution": "internal"
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}

================
File: hooks/useColorScheme.ts
================
export { useColorScheme } from 'react-native';

================
File: hooks/useColorScheme.web.ts
================
// NOTE: The default React Native styling doesn't support server rendering.
// Server rendered styles should not change between the first render of the HTML
// and the first render on the client. Typically, web developers will use CSS media queries
// to render different styles on the client and server, these aren't directly supported in React Native
// but can be achieved using a styling library like Nativewind.
export function useColorScheme() {
  return 'light';
}

================
File: hooks/useThemeColor.ts
================
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { useColorScheme } from 'react-native';

import { Colors } from '@/constants/Colors';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}

================
File: package.json
================
{
  "name": "app-meupedido",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "lint": "expo lint"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.2",
    "@react-navigation/native": "^6.0.2",
    "expo": "~51.0.39",
    "expo-constants": "~16.0.2",
    "expo-font": "~12.0.9",
    "expo-linking": "~6.3.1",
    "expo-router": "~3.5.24",
    "expo-splash-screen": "~0.27.7",
    "expo-sqlite": "~14.0.6",
    "expo-status-bar": "~1.12.1",
    "expo-system-ui": "~3.0.7",
    "expo-web-browser": "~13.0.3",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "react-native": "0.74.5",
    "react-native-gesture-handler": "~2.16.1",
    "react-native-picker-select": "^9.3.1",
    "react-native-reanimated": "~3.10.1",
    "react-native-safe-area-context": "4.10.5",
    "react-native-screens": "3.31.1",
    "react-native-web": "~0.19.10",
    "expo-file-system": "~17.0.1",
    "@react-native-async-storage/async-storage": "1.23.1",
    "@react-native-community/datetimepicker": "8.0.1"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "@types/jest": "^29.5.12",
    "@types/react": "~18.2.45",
    "@types/react-test-renderer": "^18.0.7",
    "jest": "^29.2.1",
    "jest-expo": "~51.0.3",
    "react-test-renderer": "18.2.0",
    "typescript": "~5.3.3"
  },
  "private": true,
  "packageManager": "yarn@1.22.22+sha512.a6b2f7906b721bba3d67d4aff083df04dad64c399707841b7acf00f6b133b7ac24255f2652fa22ae3534329dc6180534e98d17432037ff6fd140556e2bb3137e"
}

================
File: README.md
================
# Lanchonete App

Aplicativo mobile desenvolvido em React Native para gestão completa de lanchonetes, oferecendo funcionalidades de vendas, controle de estoque, gestão de usuários e relatórios.

## 🚀 Sobre o Projeto

Este aplicativo foi desenvolvido para atender às necessidades de lanchonetes de pequeno e médio porte, oferecendo uma solução completa e intuitiva para gestão do negócio através de dispositivos móveis.

## 💻 Tecnologias Utilizadas

- React Native
- TypeScript
- SQLite
- Redux
- React Navigation
- Styled Components

## 📱 Funcionalidades Principais

- Gestão de vendas e pedidos
- Controle de estoque
- Gestão de usuários e permissões
- Relatórios gerenciais
- Funcionamento offline
- Backup automático

## 📋 Requisitos do Sistema

### Requisitos Funcionais

#### Gestão de Usuários
- Cadastro de funcionários com níveis de acesso
- Autenticação com login e senha
- Recuperação de senha
- Edição de perfil

#### Gestão de Vendas
- Registro de vendas com itens e quantidades
- Geração de número único por venda
- Cálculo automático de valores
- Múltiplas formas de pagamento
- Histórico de vendas

#### Gestão de Estoque
- Cadastro e controle de produtos
- Atualização automática após vendas
- Sistema de alertas
- Histórico de movimentações

#### Relatórios
- Vendas por período
- Produtos mais vendidos
- Movimentação de estoque
- Fluxo de caixa

### Requisitos Não Funcionais

#### Usabilidade
- Interface intuitiva para mobile
- Modo escuro/claro
- Tempo de resposta < 2s
- Feedback visual

#### Performance
- Funcionamento offline
- Suporte multi-usuário
- Backup automático

#### Segurança
- Criptografia de dados
- Log de operações
- Logout automático
- Validação de dados

## 🔧 Configuração do Ambiente

1. Clone o repositório

```bash
git clone https://github.com/your-username/lanchonete-app.git
```

2. Install dependencies

   ```bash
   npm install
   ```

3. Start the app

   ```bash
    npx expo start
   ```

In the output, you'll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## Learn more

To learn more about developing your project with Expo, look at the following resources:

- [Expo documentation](https://docs.expo.dev/): Learn fundamentals, or go into advanced topics with our [guides](https://docs.expo.dev/guides).
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/): Follow a step-by-step tutorial where you'll create a project that runs on Android, iOS, and the web.

## Join the community

Join our community of developers creating universal apps.

- [Expo on GitHub](https://github.com/expo/expo): View our open source platform and contribute.
- [Discord community](https://chat.expo.dev): Chat with Expo users and ask questions.

================
File: scripts/reset-project.js
================
#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It moves the /app directory to /app-example and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require('fs');
const path = require('path');

const root = process.cwd();
const oldDirPath = path.join(root, 'app');
const newDirPath = path.join(root, 'app-example');
const newAppDirPath = path.join(root, 'app');

const indexContent = `import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;

const layoutContent = `import { Stack } from "expo-router";

export default function RootLayout() {
  return (
    <Stack>
      <Stack.Screen name="index" />
    </Stack>
  );
}
`;

fs.rename(oldDirPath, newDirPath, (error) => {
  if (error) {
    return console.error(`Error renaming directory: ${error}`);
  }
  console.log('/app moved to /app-example.');

  fs.mkdir(newAppDirPath, { recursive: true }, (error) => {
    if (error) {
      return console.error(`Error creating new app directory: ${error}`);
    }
    console.log('New /app directory created.');

    const indexPath = path.join(newAppDirPath, 'index.tsx');
    fs.writeFile(indexPath, indexContent, (error) => {
      if (error) {
        return console.error(`Error creating index.tsx: ${error}`);
      }
      console.log('app/index.tsx created.');

      const layoutPath = path.join(newAppDirPath, '_layout.tsx');
      fs.writeFile(layoutPath, layoutContent, (error) => {
        if (error) {
          return console.error(`Error creating _layout.tsx: ${error}`);
        }
        console.log('app/_layout.tsx created.');
      });
    });
  });
});

================
File: tsconfig.json
================
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}

================
File: utils/format.ts
================
export const formatCurrency = (value: number): string => {
  return new Intl.NumberFormat("pt-BR", {
    style: "currency",
    currency: "BRL",
  }).format(value);
};

export const formatDate = (date: Date): string => {
  return new Intl.DateTimeFormat("pt-BR").format(date);
};

export const formatDateTime = (date: Date): string => {
  return new Intl.DateTimeFormat("pt-BR", {
    dateStyle: "short",
    timeStyle: "short",
  }).format(date);
};
